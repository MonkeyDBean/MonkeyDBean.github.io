<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[塞尔达传说(旷野之息)全神庙位置概览]]></title>
    <url>%2F2018%2F09%2F22%2Fzelda_temple_map%2F</url>
    <content type="text"><![CDATA[The Legend of Zelda: Breath of the Wild 是任天堂出版发行的开放世界动作冒险游戏。 基础120 + DLC16共计136神庙注：双子峰有三个神庙 游戏截图 非常喜欢这款神作，游戏时长大于两百小时，美中不足是单人游戏，不可一起冒险。附几张游戏截图：另附还剩最后几个神庙时，对象帮着定位的截图： 其他Labo海陆空最近入手的一款游戏为Labo3-海陆空套件，拼接共耗时六个多小时，很有创意的游戏玩具，其扩展玩法边玩边探索。拼接完成后，建议穿袜子玩，防止脚汗沾湿脚踏板；labo系列有个小问题就是占地方，后续持续吃灰的可能性大。附几张与对象拼接及游戏的图片： 游戏推荐已入手的Switch游戏(均为不同类型)，按个人喜好程度排序为：第一梯队：塞尔达、奥德赛(马里奥, 纯真的乐趣)、马车8(多人对战最爱)第二梯队：Labo3-海陆空(拼装过程乐趣多)、Arms(体感对战)第三梯队：puyo-tetris(俄罗斯方块)、剪剪世界(全年龄段)、喷射2(技术菜，对新人不友好)、海贼无双3(粉丝向割草游戏)新入坑玩家，可优先考虑前三个。期待年末的宝可梦和大乱斗。]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frp搭建，实现内网穿透（端口映射）]]></title>
    <url>%2F2018%2F04%2F27%2Ffrp-map%2F</url>
    <content type="text"><![CDATA[内网穿透基本知识参照ngrok搭建 搭建环境准备外网服务器系统为centos7, 内网客户端系统为win7；一个指向外网服务器的公网域名 工具下载git开源项目，release包地址, 下载最新的，这里使用的版本为v0.17.0外网服务下执行：12345wget https://github.com/fatedier/frp/releases/download/v0.17.0/frp_0.17.0_linux_amd64.tar.gztar -zxvfcd frp_0.17.0_linux_amd64/ 客户端直接下载，被墙的话，就开代理全局模式下载。 配置,连接外网服务器编辑frps.ini文件12345[common]# 与客户端绑定，进行通信的端口号bind_port = 7000# 访问客户端web服务器的自定义端口号vhost_http_port = 7001 执行命令开启服务,格式为程序 -c 配置文件，&amp;符号指定服务后台运行。1./frps -c ./frps.ini &amp; 内网客户端编辑frpc.ini文件12345678910111213[common]# 外网服务器ipserver_addr = **.**.**.**#与服务端bind_port一致server_port = 7000[web]# 声明协议类型type = http#内网机器web服务端口local_port = 8060# 指向外网服务的公网域名custom_domains = yourdomain 执行./frpc.exe，连接服务 访问浏览器输入外网地址，访问内网服务，格式为yourdomain:7001/youpath如下图：外网服务器日志内网服务器日志浏览器显示至此，使用frp完成基本的内网穿透，通过外网可访问内网的web项目，实际可用于解决本地调试第三方回调。 扩展监听多端口，frpc.ini如下12345678910111213[common]server_addr = **.**.**.**server_port = 7000[web1]type = httplocal_port = 8070custom_domains = yourdomain1[web2]type = httplocal_port = 8080custom_domains = yourdomain2 frp功能强大，通过配置frpc.ini和frpc.ini，可实现通过外网ssh登录内网机器、远程桌面、查看frp dashboard、https访问等，配置都很简单，需要则查阅相关资料。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot Session + Redis Sentinel]]></title>
    <url>%2F2018%2F04%2F17%2Fredis_sentinel%2F</url>
    <content type="text"><![CDATA[Redis HA官方提供两种方案，Cluster（分片）及Sentinel（哨兵模式），这里仅介绍Sentinel配置及使用。两者不冲突，实际可同时使用。Sentinel优势如下： 监控（Monitoring）: 不断检查主从服务器是否运行正常 通知（Notification) : 被监控的某个redis服务器出现问题时，可通过api通知管理员或其他应用程序 自动故障迁移（Automatic Failover）: 当主服务器不能正常工作时，失效主服务器的其中一台从服务器升级为新的主服务器，失效主服务器的其他从服务器从属于新主服务器；客户端尝试连接失效主服务器时，集群返回客户端新的主服务器地址，保证可用性 Redis集群搭建Redis Sentinel方案至少需一个Master节点，两个Slave节点，三个Sentinel，本例Redis版本号为3.2.10，使用六个节点，拓扑结构如下： 配置文件 redis-6379.conf12345678910111213141516171819202122# 端口port 6379# 默认为127.0.0.1。0.0.0.0不是真正意义的ip，指本机所有的ipv4地址bind 0.0.0.0# 守护进程方式，redis在后台运行daemonize yes# 日志文件名，日志记录启动过程以及故障转移过程logfile &quot;6379.log&quot;# 指定本地数据库文件名（默认为dump.rdb），redis重启时，将此文件内容执行一遍，获取数据。若开启appendonly，则优先使用appendonly.aof文件初始化数据集，不再使用此rdb文件dbfilename &quot;dump-6379.rdb&quot;# 工作目录，数据文件及日志文件存储路径dir &quot;/data/home/qa/redis_config/data&quot;# 安全策略，保护模式，开启则禁止公网访问redis, 开启的条件包括没有绑定ip以及没有设置访问密码，即不设置bind及requirepass参数protected-mode no# 访问主节点密码masterauth root# redis-server密码requirepass root# aof日志开启，每次写操作就会记录一条日志appendonly yes# 指定日志文件名（默认为appendonly.aof），redis重启时，将此文件内容执行一遍，获取数据appendfilename appendonly.aof 注：Redis有两种持久化方式，Snapshot(rdb)和Append-only file(aof)。可使用其中一种方式，也可以两种都使用。 rdb方式的持久化通过快照完成，即符合一定条件时redis会自动将内存中的所有数据存储到rdb文件中。相对aof方式，rdb文件更小，数据恢复快，但是会丢失最后一次snapshot后更改的所有数据，如果容忍数据丢失，可采用这种方式。本例对应配置参数为dbfilename “dump-6379.rdb” aof方式，redis默认不开启，aof方式是以追加的方式将所有写操作命令写入到磁盘文件.aof中，所以文件会越来越大，redis重启的恢复时间较长，为了缓解这种问题，redis使用了BGREWRITEAOF，用于删除重复多余的写命令，是一个占用一定系统资源的background进程（redis自行触发），因为rewrite的时候会删除旧的AOF文件，如果AOF文件比较大的话，会消耗更多的系统资源，好处就是数据一般不会丢失。本例对应配置参数为appendonly yesappendfilename appendonly.aof redis-6380.conf12345678910111213port 6380bind 0.0.0.0daemonize yeslogfile &quot;6380.log&quot;dbfilename &quot;dump-6380.rdb&quot;dir &quot;/data/home/qa/redis_config/data&quot;protected-mode nomasterauth rootrequirepass rootappendonly yesappendfilename appendonly.aof# 指定主节点ip及端口号,若需外网访问，改为本机的外网地址slaveof 127.0.0.1 6379 redis-6381.conf12345678910111213port 6381bind 0.0.0.0daemonize yeslogfile &quot;6381.log&quot;dbfilename &quot;dump-6381.rdb&quot;dir &quot;/data/home/qa/redis_config/data&quot;protected-mode nomasterauth rootrequirepass rootappendonly yesappendfilename appendonly.aof# 指定主节点ip及端口号,若需外网访问,改为本机的外网地址slaveof 127.0.0.1 6379 sentinel-36379.conf123456789101112131415161718192021222324252627# sentinel节点端口port 36379# 工作目录dir &quot;/data/home/qa/redis_config/data&quot;# 日志文件logfile &quot;36379.log&quot;# 不开启保护模式protected-mode no# 守护进程，后台运行daemonize yes# 监控的主节点，mymaster为自定义的主节点别名，127.0.0.1为监听访问ip，如需外网访问则改为本机外网ip, 6379为端口号，2表示判断主节点失效至少需两个sentinel节点同意sentinel monitor mymaster 127.0.0.1 6379 2# 设置连接master和slave时的密码。sentinel不能分别为master和slave设置不同的密码，因此master和slave的密码应该设置相同sentinel auth-pass mymaster root# 每个sentinel节点均要定期执行ping命令判断Redis数据节点和其他sentinel节点是否可达，超过30000毫秒认为不可达sentinel down-after-milliseconds mymaster 30000# 当sentinel节点集合对主节点故障判断达成一致时，故障迁移选出新节点，原来的从节点会向新主节点发起复制操作，限制每次想新主节点发起复制操作的从节点个数为1sentinel parallel-syncs mymaster 1# 故障转移超时时间sentinel failover-timeout mymaster 180000 sentinel-36380.conf和sentinel-36381.conf配置（除sentinel节点端口和日志文件名）与sentinel-36379.conf配置相同。其他参数备注，本例不使用：123456789# 故障转移期间，当warn级别的Sentinel事件发生时（指重要事件，如master不可达,sentinel判断master下线），会触发对应路径的脚本，向脚本发送相应的事件参数。sentinel notification-script $master_name $script_path_and_name例如sentinel notification-script mymaster /data/home/qa/redis_config/notify.sh# 故障转移结束后，触发应对路径的脚本，并向脚本发送故障转移结果参数sentinel client-reconfig-script $master_name $script_path_and_name例如sentinel client-reconfig-script mymaster /data/home/qa/redis_config/reconfig.sh 验证root模式下 启动主从节点123redis-server redis-6379.confredis-server redis-6380.confredis-server redis-6381.conf 此时从属关系如下图登入主从节点，查看主从状态如下图 启动sentinel启动三个sentinel，可用两种方式，如12redis-sentinel sentinel-36379.confredis-server sentinel-36380.conf --sentinel redis sentinel部署完成后,sentinel配置文件发生如下变化： sentinel节点自动发现了从节点、其余Sentinel节点 去掉了默认配置，如：parallel-syncs、failover-timeout 新添加了参数，如epoch 此时查看sentinel-36379.conf配置文件如下 故障转移实验干掉主节点后，查看sentinel节点监控的主节点信息，如下图，可以看到，节点6381成为主节点查看从节点信息如下图，原本的主节点（端口6379）已经断开了连接重启端口为6379的数据节点后，查看从节点信息，可以看到6379节点复活，不过此时已经降级为端口6381的从节点，如下图 延迟测试同一网段下的其他机器连接redis，平均耗时为2ms， 如下所示：1redis-cli --latency -h $host -p $port 通过如下命令可查看当前连接数及配置的最大连接数12info clientsconfig get maxclients Springboot 接入开始接入依赖12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;1.3.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置示例配置从哪里读取无所谓，本例的配置从apollo读取，如下图： Java类配置类RedisCon123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import com.ctrip.framework.apollo.spring.annotation.EnableApolloConfig;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@ConfigurationProperties(prefix = &quot;redisCon&quot;)@Component(&quot;redisCon&quot;)@EnableApolloConfig(value = &quot;RedisCon&quot;)public class RedisCon &#123; /** * 主节点名称,mymaster */ private String masterName; /** * 哨兵集群，ip:port,ip:port */ private String sentinelAddress; /** * 连接池建立最大连接数 */ private int maxActive; /** * 最大空闲数 */ private int maxIdle; /** * 最小空闲数 */ private int minIdle; /** * 最大阻塞时间, 毫秒 */ private int maxWaitTime; /** * redis数据节点密码 */ private String password; /** * 连接超时时间，单位毫秒 */ private int timeout; /** * 数据库索引 */ private int dbIndex; public String getMasterName() &#123; return masterName; &#125; public void setMasterName(String masterName) &#123; this.masterName = masterName; &#125; public String getSentinelAddress() &#123; return sentinelAddress; &#125; public void setSentinelAddress(String sentinelAddress) &#123; this.sentinelAddress = sentinelAddress; &#125; public int getMaxActive() &#123; return maxActive; &#125; public void setMaxActive(int maxActive) &#123; this.maxActive = maxActive; &#125; public int getMaxIdle() &#123; return maxIdle; &#125; public void setMaxIdle(int maxIdle) &#123; this.maxIdle = maxIdle; &#125; public int getMinIdle() &#123; return minIdle; &#125; public void setMinIdle(int minIdle) &#123; this.minIdle = minIdle; &#125; public int getMaxWaitTime() &#123; return maxWaitTime; &#125; public void setMaxWaitTime(int maxWaitTime) &#123; this.maxWaitTime = maxWaitTime; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getTimeout() &#123; return timeout; &#125; public void setTimeout(int timeout) &#123; this.timeout = timeout; &#125; public int getDbIndex() &#123; return dbIndex; &#125; public void setDbIndex(int dbIndex) &#123; this.dbIndex = dbIndex; &#125;&#125; RedisConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.connection.RedisSentinelConfiguration;import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;import org.springframework.stereotype.Component;import redis.clients.jedis.JedisPoolConfig;@Component@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 86400)public class RedisConfig &#123; private final RedisCon redisCon; @Autowired public RedisConfig(RedisCon redisCon) &#123; this.redisCon = redisCon; &#125; @Bean public RedisSentinelConfiguration sentinelConfig() &#123; RedisSentinelConfiguration sentinelConfig = new RedisSentinelConfiguration().master(redisCon.getMasterName()); String[] sentinelNodes = redisCon.getSentinelAddress().split(&quot;,&quot;); for (String node : sentinelNodes) &#123; String[] ipAndPort = node.split(&quot;:&quot;); String nodeIp = ipAndPort[0]; Integer nodePort = Integer.valueOf(ipAndPort[1]); sentinelConfig.sentinel(nodeIp, nodePort); &#125; return sentinelConfig; &#125; @Bean public RedisConnectionFactory redisConnectionFactory() &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(redisCon.getMaxActive()); jedisPoolConfig.setMaxIdle(redisCon.getMaxIdle()); jedisPoolConfig.setMinIdle(redisCon.getMinIdle()); jedisPoolConfig.setMaxWaitMillis(redisCon.getMaxWaitTime()); JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(sentinelConfig(), jedisPoolConfig); jedisConnectionFactory.setDatabase(redisCon.getDbIndex()); jedisConnectionFactory.setPassword(redisCon.getPassword()); if(redisCon.getPassword() != null &amp;&amp; !&quot;&quot;.equals(redisCon.getPassword()))&#123; jedisConnectionFactory.setPassword(redisCon.getPassword()); &#125; jedisConnectionFactory.setTimeout(redisCon.getTimeout()); jedisConnectionFactory.afterPropertiesSet(); return jedisConnectionFactory; &#125; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate() &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory()); return template; &#125;&#125; 至此，完成集群配置及接入。 问题备注1.使用redis作为session，需在logback.xml中更改日志级别不为debug，否则有日志打印过多的报警1&lt;logger name=&quot;org.springframework.session.web.http.SessionRepositoryFilter.SESSION_LOGGER&quot; level=&quot;WARN&quot;/&gt; 2.若构建RedisConnectionFactory Bean时（即RedisConfig类的redisConnectionFactory方法）不加 jedisConnectionFactory.afterPropertiesSet();，那么在连接redis时，抛异常Cannot get Jedis connection; nested exception is java.lang.NullPointerException。查源码，从JedisSentinelPool类的构造函数追溯，被JedisConnectionFactory类的createRedisSentinelPool方法调用，逐步向上推，最后可得关键方法afterPropertiesSet()，源码如下： 12345678910111213141516171819202122232425/* * (non-Javadoc) * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet() */public void afterPropertiesSet() &#123; if (shardInfo == null) &#123; shardInfo = new JedisShardInfo(hostName, port); if (StringUtils.hasLength(password)) &#123; shardInfo.setPassword(password); &#125; if (timeout &gt; 0) &#123; setTimeoutOn(shardInfo, timeout); &#125; &#125; if (usePool &amp;&amp; clusterConfig == null) &#123; this.pool = createPool(); &#125; if (clusterConfig != null) &#123; this.cluster = createCluster(); &#125;&#125; 3.本地window开发环境没有问题，linux环境启动报错如下1234Error ： redis clients jedis HostAndPort cant resolve localhost addressjava.net.UnknownHostException: tencent_QA_test11······ 解决：①.查看linux系统主机名，shell输入hostname返回tencent_QA_test11②.查看/etc/hosts文件中是否有127.0.0.1对应主机名，如果没有则添加1127.0.0.1 localhost localhost.localdomain VM_100_8_centos tencent_QA_test11]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探Springboot-Redis]]></title>
    <url>%2F2018%2F03%2F24%2Fdocker_redis%2F</url>
    <content type="text"><![CDATA[仅用缓存功能，不与JPA结合。Redis及Docker的基础用法自行查询。 环境准备，安装配置Win71.官网下载redis, 在解压后的目录打开cmd(按住shift, 鼠标右键)，输入1redis-server redis.windows.conf 出现如下界面为启动成功 2.再打开一个cmd，执行 redis-cli 如下 3.在系统变量Path中添加redis目录，下次执行redis-server和redis-cli不必在redis安装目录下 Centos71.安装redis1yum install -y redis 2.配置123vim /etc/redis.config，更改配置，如bind 由127.0.0.1改为0.0.0.0, 可供外网访问requirepass解开注释，设置密码 3.连接1redis-cli -h 127.0.0.1 -p 6379 -a root Centos7 Docker1.官网docker.io经常不可访问，加入镜像123vim /etc/docker/daemon.json可加如下镜像&quot;registry-mirror&quot; : [&quot;http://33bfbfda.m.daocloud.io&quot;] 2.查看下载redis镜像12docker search redisdocker pull redis 3.起redis服务1docker run -d --name myredis -p 6379:6379 -v $PWD/data:/data c53 --requirepass root --appendonly yes 参数解读： -d ： 后台运行 –name ： 命名容器名 -p 6379:6379 ： 指定端口映射，前一个6379为宿主机端口号，后一个6379为容器端口号 -v $PWD/data:/data ： 将主机中当前目录下的data挂载到容器的/data –requirepass root : 设置密码为root，保护 Redis 服务器 –redis-server –appendonly yes :在容器执行redis-server启动命令，并打开redis持久化配置 4.连接redis-server1redis-cli -h host -p port -a password 或者如下图 注：auth password 和配置文件中的密码相符，服务器会返回 OK 并开始接受命令输入; 密码错误或不输入密码，虽然可以连接上redis，但不可使用其他redis命令。redis容易遭受密码猜测攻击，所以要确保密码足够复杂和足够长。 SpringBoot 引入 Redis1.引入依赖, 版本与spring-boot-starter-parent一致123456&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2.从配置中获取redis连接信息，若从application.properties中获取，则设置如下12345678910## redis服务器地址redisCon.host = 115.159.204.52## 端口号redisCon.port = 6379## 密码redisCon.password = root## 数据库索引redisCon.dbIndex = 0## 连接超时时间，单位毫秒redisCon.timeout = 5000 配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@ConfigurationProperties(prefix = &quot;redisCon&quot;)@Component(&quot;redisCon&quot;)public class RedisCon &#123; /** * redis服务器地址 */ private String host; /** * 端口号 */ private int port; /** * 密码 */ private String password; /** * 数据库索引 */ private int dbIndex; /** * 连接超时时间,单位毫秒 */ private int timeout; public String getHost() &#123; return host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getDbIndex() &#123; return dbIndex; &#125; public void setDbIndex(int dbIndex) &#123; this.dbIndex = dbIndex; &#125; public int getTimeout() &#123; return timeout; &#125; public void setTimeout(int timeout) &#123; this.timeout = timeout; &#125; &#125; 3.配置连接池123456789101112131415161718192021222324252627282930313233343536import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;@Componentpublic class RedisConfig &#123; private final RedisCon redisCon; @Autowired public RedisConfig(RedisCon redisCon) &#123; this.redisCon = redisCon; &#125; @Bean public JedisConnectionFactory redisConnectionFactory() &#123; JedisConnectionFactory factory = new JedisConnectionFactory(); factory.setHostName(redisCon.getHost()); factory.setPort(redisCon.getPort()); factory.setPassword(redisCon.getPassword()); factory.setTimeout(redisCon.getTimeout()); factory.setDatabase(redisCon.getDbIndex()); factory.afterPropertiesSet(); return factory; &#125; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate() &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory()); return template; &#125;&#125; 4.方法封装，以HashMap为例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.HashOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;@Componentpublic class RedisUtil &#123; private static RedisTemplate redisTemplate; private static HashOperations&lt;String, String, Object&gt; hashOperations; @Autowired @SuppressWarnings(&quot;unchecked&quot;) public RedisUtil(RedisTemplate redisTemplate) &#123; RedisUtil.redisTemplate = redisTemplate; RedisUtil.hashOperations = RedisUtil.redisTemplate.opsForHash(); &#125; /** * 获取指定hash值 * * @param hashName hash表名称 * @param hashKey hash表key * @return hash value, 若不存在返回null */ public static Object getHashValue(String hashName, String hashKey) &#123; return RedisUtil.hashOperations.get(hashName, hashKey); &#125; /** * 写入指定的hash值 * * @param hashName hash表名称 * @param hashKey hash表key * @param hashValue hash value * @return 写入成功返回true */ public static boolean setHashValue(String hashName, String hashKey, Object hashValue) &#123; RedisUtil.hashOperations.put(hashName, hashKey, hashValue); return true; &#125; /** * 增加指定的HashKey */ public static Long incrementHashValue(String hashName, String hashKey, Long increment) &#123; return RedisUtil.hashOperations.increment(hashName, hashKey, increment); &#125; /** * 删除指定数据 */ @SuppressWarnings(&quot;unchecked&quot;) public static void deleteKey(String key) &#123; RedisUtil.redisTemplate.delete(key); &#125;&#125; 5.测试1234567891011121314151617181920212223242526272829303132333435import com.kodgames.bus.component.config.redis.RedisUtil;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@Api(value = &quot;测试接口&quot;)@RequestMapping(path = &quot;testtest&quot;)@RestControllerpublic class TestController &#123; private static Logger logger = LoggerFactory.getLogger(TestController.class); @ApiOperation(value = &quot;测试redis hash&quot;) @RequestMapping(path = &quot;hash/redis&quot;, method = RequestMethod.GET) public Long testHashRedis() &#123; String hashName = &quot;testHash&quot;; String hashKey = &quot;testKey1&quot;; Long hashValue = 123L; Long firstGetHashValue = (Long) RedisUtil.getHashValue(hashName, hashKey); logger.info(&quot;firstGetHashValue: &#123;&#125;&quot;, firstGetHashValue); logger.info(&quot;set hash value: &#123;&#125;&quot;, RedisUtil.setHashValue(hashName, hashKey, hashValue)); logger.info(&quot;secondGetHashValue: &#123;&#125;&quot;, RedisUtil.getHashValue(hashName, hashKey)); RedisUtil.deleteKey(hashName); logger.info(&quot;thirdGetHashValue: &#123;&#125;&quot;, RedisUtil.getHashValue(hashName, hashKey)); String hashIncre = &quot;incrementMap&quot;; String hashKeyIncre = &quot;incrementKey&quot;; long num = RedisUtil.incrementHashValue(hashIncre, hashKeyIncre, 1L); logger.info(&quot;incrementValue: &#123;&#125;&quot;, num); return num; &#125;&#125; 测试结果如下： 共享sessoin为多点部署，借助redis实现共享session 1.引入依赖123456&lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;1.3.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2. 注解只需在上述的RedisConfig加一行注解即可12345@Component@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)public class RedisConfig &#123; //省略&#125; 3.测试接口12345678910@ApiOperation(value = &quot;测试session&quot;)@GetMapping(&quot;session/uid&quot;)public Object getSessionUid(HttpSession session)&#123; UUID uid = (UUID) session.getAttribute(&quot;uid&quot;); if (uid == null) &#123; uid = UUID.randomUUID(); &#125; session.setAttribute(&quot;uid&quot;, uid); return session.getAttribute(&quot;uid&quot;);&#125; 请求结果如下：连上redis,查看 4.身份验证未使用redis session前，重启服务后，session失效，需重新验证。接入redis session后，重启服务，访问，无需身份验证，session已存储在redis中。]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引入Springboot AOP]]></title>
    <url>%2F2018%2F02%2F25%2Fspring-aop%2F</url>
    <content type="text"><![CDATA[统一日志初步处理。 添加maven依赖，版本与starter-parent一致123456&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt;&lt;/dependency&gt; 注解简介详情查阅官网。@Pointcut: 定义切点 execution: 匹配方法执行的连接点,语法为：execution(方法修饰符(可选) 返回类型 方法名 参数 异常模式(可选)) @Before: 前置方法 @AfterReturning: 后置返回方法 @AfterThrowing: 异常抛出时调用 @After: 同final, 无论异常抛出还是正常退出，均调用 @Around: 环绕通知，即同@Before与@After结合 @Order: 当有多个aspect时使用，定义优先级，值越小，执行顺序越高 方法调用顺序： 实例请求日志123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import com.kodgames.bus.component.reqres.Result;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import java.util.Arrays;/** * 请求日志 */@Aspect@Componentpublic class WebLogAspect &#123; private static Logger logger = LoggerFactory.getLogger(WebLogAspect.class); private ThreadLocal&lt;Long&gt; beginTime = new ThreadLocal&lt;&gt;(); @Pointcut(&quot;execution(public * com.kodgames.bus.controller.*.*(..))&quot;) //监听所有controller的所有公共方法 public void controllerPoint() &#123; &#125; @Before(&quot;controllerPoint()&quot;) public void doBefore(JoinPoint joinPoint) &#123; //请求到达时间 beginTime.set(System.currentTimeMillis()); ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); logger.info(&quot;Request Url: &quot; + request.getRequestURL().toString()); logger.info(&quot;Http Method: &quot; + request.getMethod()); logger.info(&quot;Class Method: &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName()); logger.info(&quot;Args: &quot; + Arrays.toString(joinPoint.getArgs())); &#125; @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;controllerPoint()&quot;) public void doAfterReturning(Object ret) throws Throwable &#123; logger.info(&quot;Response is: &quot; + ret); if (ret instanceof Result) &#123; Result result = (Result) ret; logger.info(&quot;Response code is &quot; + result.getCode()); logger.info(&quot;Response message is &quot; + result.getMsg()); &#125; logger.info(&quot;method execute takes: &#123;&#125; ms&quot;, System.currentTimeMillis() - beginTime.get()); &#125;&#125; 注：Result类数据结构如下123456public class Result&lt;T&gt; &#123; private int code; private String msg; private String des; private T data;&#125; 测试结果如下： 数据库层日志12345678910111213141516171819202122232425262728293031323334353637383940import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.util.Arrays;/** * 数据库层日志 */@Aspect@Componentpublic class DaoLogAspect &#123; private static Logger logger = LoggerFactory.getLogger(DaoLogAspect.class); private ThreadLocal&lt;Long&gt; beginTime = new ThreadLocal&lt;&gt;(); @Pointcut(&quot;execution(public * com.kodgames.bus.dao.*.*(..))&quot;) public void daoPoint() &#123; &#125; @Before(&quot;daoPoint()&quot;) public void doBefore(JoinPoint joinPoint) &#123; //请求到达时间 beginTime.set(System.currentTimeMillis()); logger.info(&quot;Dao Class Method: &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName()); logger.info(&quot;Dao Args: &quot; + Arrays.toString(joinPoint.getArgs())); &#125; @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;daoPoint()&quot;) public void doAfterReturning(Object ret) throws Throwable &#123; logger.info(&quot;Dao Response is: &quot; + ret); logger.info(&quot;Dao Method execute takes: &#123;&#125; ms&quot;, System.currentTimeMillis() - beginTime.get()); &#125;&#125; 其他使用测试123456789101112131415161718192021222324252627/** * 与catch完全处理异常不同，AfterThrowing不能完全处理该异常，异常依然会传播到上一级调用者直至JVM*/@AfterThrowing(throwing=&quot;tr&quot;, pointcut = &quot;controllerPoint()&quot;)public void throwsTr(Throwable tr)&#123; logger.error(&quot;check throwable: &quot; + tr);&#125;//后置最终通知, final增强，不管是抛出异常或者正常退出都会执行@After(&quot;controllerPoint()&quot;)public void after()&#123; logger.info(&quot;method execute finally.....&quot;);&#125;//环绕通知@Around(&quot;controllerPoint()&quot;)public Object around(ProceedingJoinPoint pjp) &#123; logger.info(&quot;method around start.....&quot;); try &#123; Object o = pjp.proceed(); logger.info(&quot;method around proceed，result is: &quot; + o); return o; &#125; catch (Throwable e) &#123; logger.error(&quot;@Around get throwable: &quot; + e); return null; &#125;&#125;]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库字段加盐]]></title>
    <url>%2F2017%2F12%2F02%2Fsql_salt%2F</url>
    <content type="text"><![CDATA[为保证数据安全，数据库密码类字段设计成不可逆的定长密文，转为密文的过程需加盐。写了个编码工具类，数据库字段的安全性可以保障。 防撞库（密码碰撞攻击），大多数用户习惯问题，多个网站使用同一密码， 某个网站数据泄露后，其他网站密码若使用明文存储，就太尴尬了，用户账号安全性完全没有保障。 防拖库后用户密码泄露，若数据库通过sql注入被拖库，攻击者即便拿到数据，密码为不可逆的密文，保证了用户密码不会被泄露。（不过话说回来，已经被拖库了，虽然密码不会暴露，但用户信息已经泄露了。。。） 防彩虹表攻击。攻击者一般会事先建表或直接使用网上已有的各种库，单次哈希算法基本都已无效，虽然算法不可逆，但是查表可得密码。这种情况就需要算法不暴露，当然最关键的还是加盐。 Encode工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import org.apache.commons.codec.binary.Base64;import org.apache.commons.codec.digest.DigestUtils;import java.security.MessageDigest;/** * Created by Bean on 2017/12/1. */public class EncodeUtil &#123; /** * 密码加盐,预防保障数据库泄露的用户信息安全,防密码碰撞攻击 */ private static final String PASSWORD_SALT = &quot;helloBeanSherry%salt&amp;ok=monkey_bean&quot;; private static final int HASH_COUNT = 3; /** * 密码编码 */ public static String encodePassword(String password) &#123; return encodeStrMd5(password, PASSWORD_SALT, HASH_COUNT); &#125; /** * 对密码做md5摘要+base64 * @param origin 原始字符串 * @param salt 盐 * @param count hash次数 */ public static String encodeStrMd5(String origin, String salt, int count) &#123; String originAddSalt = twoStringXor(origin, salt); String destMd5 = encodeMd5ByteDirectToBase64(originAddSalt); if (count == 1) &#123; return destMd5; &#125; else &#123; return encodeStrMd5(destMd5, salt, --count); &#125; &#125; /** * 两个字符串异或 */ private static String twoStringXor(String firstStr, String secondStr)&#123; byte[] firstBytes = firstStr.getBytes(); byte[] secondBytes = secondStr.getBytes(); byte[] shortBytes, longBytes; if(firstBytes.length &gt;= secondBytes.length)&#123; shortBytes = secondBytes; longBytes = firstBytes; &#125;else&#123; shortBytes = firstBytes; longBytes = secondBytes; &#125; byte[] xorBytes = new byte[longBytes.length]; int i = 0; for(; i&lt;shortBytes.length; i++)&#123; xorBytes[i] = (byte)(shortBytes[i] ^ longBytes[i]); &#125; for(; i&lt;longBytes.length; i++)&#123; xorBytes[i] = longBytes[i]; &#125; return new String(xorBytes); &#125; /** * encode * MD5 bye[] direct to Base64 */ private static String encodeMd5ByteDirectToBase64(String origin)&#123;// // 库MessageDigest// String result = &quot;&quot;;// try &#123;// MessageDigest md;// md = MessageDigest.getInstance(&quot;MD5&quot;);// md.update(origin.getBytes());// result = new String(Base64.encodeBase64(md.digest()));// &#125; catch (Exception e) &#123;// e.printStackTrace();// &#125;// return result; // 库DigestUtils return new String(Base64.encodeBase64(DigestUtils.md5(origin))); &#125; /** * encode * MD5 string, then to base64 */ private static String encodeMd5HexToBase64(String origin)&#123; String Md5Hex = DigestUtils.md5Hex(origin); return new String(Base64.encodeBase64(Md5Hex.getBytes())); &#125;&#125; 思想：明文密码传入, 与盐做异或运算，得值，将值Md5，得到字节数据，直接进行base64运算。将以上步骤重复多次，得到结果即为存储值。 测试类仅查看输出结果唯一。123456789101112131415161718192021222324import junit.framework.TestCase;/** * Created by Bean on 2017/12/1. */public class EncodeUtilTest extends TestCase &#123; public void setUp() throws Exception &#123; super.setUp(); &#125; public void tearDown() throws Exception &#123; &#125; public void testEncodePassword() throws Exception &#123; String origin = &quot;a12345678&quot;; String result = EncodeUtil.encodePassword(origin); System.out.println(&quot;origin: &quot; + origin); System.out.println(&quot;result: &quot; + result); assertTrue(EncodeUtil.encodePassword(origin).equals(result)); &#125;&#125; 测试输出md5得到字节数组直接进行base64(第一种) 与 md5转为字符串再base64（第二种）不是一回事，结果完全不同。 第一种encodeStrMd5调用encodeMd5ByteDirectToBase6412origin: a12345678result: 8yWH0mpMi2UxufmvlfPLqQ== 第二种encodeStrMd5调用encodeMd5HexToBase6412origin: a12345678result: YmI4YmZmNjY5OTAzYzU5NmJlM2FhODZhODYyOGI2NjQ=]]></content>
      <tags>
        <tag>技术</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后端安全策略初探]]></title>
    <url>%2F2017%2F12%2F02%2Ftransfer_safety%2F</url>
    <content type="text"><![CDATA[前后端的通信安全，若想完全保障，则要使用https，从tcp层保证传输安全，但https从证书申请、搭建、到使用，成本感人，目前国内只有主流大型网站使用。目前大多数网站还是使用的http。用户的密码在传输时必须是密文，由于前端代码本就是暴露的，即便通过加密混淆也可以反解，所以前端的加密方法必须是不可逆的，若可逆则只能防小白。所以通过算法的安全性保证传输安全。以登录为例。 密码安全性方法一，N次Md51.数据库存储的密码字段为md5Hex + DES(AES)。2.前端首先对密码进行单次Md5摘要CryptoJS.MD5(value).toString(CryptoJS.enc.Base64)，Date.now()获取当前时间stime,根据stime尾数（0-9）再进行n次Md5，尾数为6,也就是循环6遍Md5摘要，stime的随机性使每次Md5摘要值都不同，可简单防范。3.后端对比密码是否正确时，首先从数据库读取密码存储的密文字段，再进行DES解密, 然后根据stime, 对dbPassword进行多次Md5运算，将运算结果与前端传的摘要密码对比即可。过程如下123456789public static final String key = &quot;helloBean&quot;;public static boolean isRightPassword(String stime, String passwordMd5, String dbPassword)&#123; dbPassword = DesUtil.decryptPsWithSlat(dbPassword, key); int loop = Integer.parseInt(stime.substring(stime.length() - 1)); for (int i = 0; i &lt; loop; i++) &#123; dbPassword = DigestUtils.md5Hex(dbPassword); &#125; return dbPassword.equals(passwordMd5); &#125; DesUtil工具类代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import org.apache.commons.codec.binary.Hex;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;import java.security.SecureRandom;public class DesUtil &#123; /** * 加密 * * @param src byte[] * @param key String * @return byte[] */ public static byte[] encrypt(byte[] src, String key) &#123; try &#123; SecureRandom random = new SecureRandom(); DESKeySpec desKey = new DESKeySpec(key.getBytes()); //创建一个密匙工厂，然后用它把DESKeySpec转换成 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;); SecretKey securekey = keyFactory.generateSecret(desKey); //Cipher对象实际完成加密操作 Cipher cipher = Cipher.getInstance(&quot;DES&quot;); //用密匙初始化Cipher对象 cipher.init(Cipher.ENCRYPT_MODE, securekey, random); //现在，获取数据并加密 //正式执行加密操作 return cipher.doFinal(src); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * * DES解密 * * @param src byte[] * @param key String * @return byte[] */ public static byte[] decrypt(byte[] src, String key) throws Exception &#123; // DES算法要求有一个可信任的随机数源 SecureRandom random = new SecureRandom(); // 创建一个DESKeySpec对象 DESKeySpec desKey = new DESKeySpec(key.getBytes()); // 创建一个密匙工厂 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;); // 将DESKeySpec对象转换成SecretKey对象 SecretKey securekey = keyFactory.generateSecret(desKey); // Cipher对象实际完成解密操作 Cipher cipher = Cipher.getInstance(&quot;DES&quot;); // 用密匙初始化Cipher对象 cipher.init(Cipher.DECRYPT_MODE, securekey, random); // 真正开始解密操作 return cipher.doFinal(src); &#125; /** * 账户密码，DES算法盐作为密钥加密, */ public static String encryptPassWithSlat(String passwdMd5, String key) &#123; String desPassword = &quot;&quot;; try &#123; byte[] enc = encrypt(passwdMd5.getBytes(), key); //加密结果需要转换成hex才能存入数据库 desPassword = Hex.encodeHexString(enc); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return desPassword; &#125; /** * 账户密码，DES算法盐作为密钥解密, */ public static String decryptPsWithSlat(String desPassword, String key) &#123; String passwdMd5 = &quot;&quot;; try &#123; //desPassword是hex格式，应该先转换 byte[] hex = Hex.decodeHex(desPassword.toCharArray()); byte[] dec = decrypt(hex, key); passwdMd5= new String(dec); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return passwdMd5; &#125; &#125; 方法二，前端加盐1.数据库存储的密码字段为加盐后的摘要。2.前端加盐后再单次摘要, 加盐建议重写异或而不是简单字符串拼接。然后根据stime做n次摘要，方法同上3.后端从数据库取出字段，做n次摘要后，与前端传输的密码比对即可。 传输安全，身份认证，防简单攻击 所有请求，均加摘要。前端获取当前时间ostime，与请求参数拼接后做一次摘要，即MD5(params + ostime)，同时将ostime传给后端，后端收到请求后，按相同方法算一次摘要，与前端传的摘要比对，相同则合法，否则返回401。防重放攻击，但攻击者通过分析前端代码可以模拟正常请求。 后端对所有请求进行时间合法性判断，与服务器时间比对，30秒以内则认为合法。简单的防重放攻击。 后端记录每个ip的每个路径的最近访问时间，本次访问时间-上次访问时间大于100ms，否则不可访问接口，返回401。 用户身份信息存储在session中，对于登录后调用的接口，后端判断session中是否有身份信息，没有则返回403。攻击者可以进行cookie劫持和session获取进行攻击，开发者可通过使用session的同时引入token防御。 能使用https一定不要使用http。 题外话之前写了一个客户端内嵌WebView与浏览器访问页面的安全机制，在那个项目，用户身份认证使用的token策略，token身份认证一般是用于客户端和服务器通信（CS），客户端可将token存储到本地数据库；前后端（BS）的身份认证则是cookie-session。]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CryptoJS的使用引入]]></title>
    <url>%2F2017%2F11%2F30%2Fmd5_base64%2F</url>
    <content type="text"><![CDATA[CryptoJS是原生javascript写的加密类库，提供了各种编码和加密算法，如MD5、SHA-1、SHA-256、AES、HMAC、PBKDF等。以常见的Md5摘要及Base64编码为例，测试代码如下： index.html12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;测试加密&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;js/jquery-3.2.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/core.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/md5.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/enc-base64.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/main.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; console.log(&quot;-----start------&quot;); var origin = &quot;a12345678&quot;; console.log(&quot;origin string is :&quot; + origin); console.log(&quot;md5 hex string is :&quot; + md5HexUtil(origin)); console.log(&quot;md5 byte direct to base64 method1 is :&quot; + md5ByteDirectToBase64UtilMethod1(origin)); console.log(&quot;md5 byte direct to base64 method2 is :&quot; + md5ByteDirectToBase64UtilMethod2(origin)); console.log(&quot;base4 encode finish :&quot; + base64Encode(origin)); console.log(&quot;base4 decode finish :&quot; + base64Decode(base64Encode(origin))); console.log(&quot;md5 hex string, and then base4 is :&quot; + base64Encode(md5HexUtil(origin))); console.log(&quot;-----end--------&quot;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; main.js1234567891011121314151617181920212223242526272829303132333435363738394041/** * Md5摘要,转为16进制字符串(Md5字节数组转String默认即是十六进制) */function md5HexUtil(value)&#123; return CryptoJS.MD5(value).toString(CryptoJS.enc.HEX);&#125;/** * Md5摘要,直接将字节流转为Base64 * 方法一： */function md5ByteDirectToBase64UtilMethod1(value)&#123; return CryptoJS.MD5(value).toString(CryptoJS.enc.Base64);&#125;/** * Md5摘要,直接将字节流转为Base64 * 方法二： */function md5ByteDirectToBase64UtilMethod2(value)&#123; var base64 = CryptoJS.enc.Base64.stringify(CryptoJS.MD5(value)); return base64;&#125;/** * base64编码 */function base64Encode(value)&#123; var wordArray = CryptoJS.enc.Utf8.parse(value); var base64 = CryptoJS.enc.Base64.stringify(wordArray); return base64;&#125;/** * base64解码 */function base64Decode(base64)&#123; var parsedWordArray = CryptoJS.enc.Base64.parse(base64); var parsedStr = parsedWordArray.toString(CryptoJS.enc.Utf8); return parsedStr;&#125; 运行结果123456789-----start------test.html:17 origin string is :a12345678test.html:18 md5 hex string is :e9bc0e13a8a16cbb07b175d92a113126test.html:19 md5 byte direct to base64 method1 is :6bwOE6ihbLsHsXXZKhExJg==test.html:20 md5 byte direct to base64 method2 is :6bwOE6ihbLsHsXXZKhExJg==test.html:21 base4 encode finish :YTEyMzQ1Njc4test.html:22 base4 decode finish :a12345678test.html:23 md5 hex string, and then base4 is :ZTliYzBlMTNhOGExNmNiYjA3YjE3NWQ5MmExMTMxMjY=test.html:24 -----end-------- 值得注意的是：MD5转为字符串再进行Base64编码（第一种）与MD5字节数组直接进行Base64编码（第二种）的输出结果不同。原因是Md5结果为128bit，转字符串时，算法默认使用16进制，每4bit为一个字节，结果得到32字节长度的定长字符串，再进行base64编码，得到44字节长度的字符串； 而第二种Md5字节流直接进行Base64编码，1字节=8bit，128bit即16字节，base64编码后为24字节。 扩展 算法 bit byte MD5 128 32 SHA1 160 40 SHA224 224 56 SHA256 256 64 SHA384 384 96 SHA512 512 128 数据摘要算法不是加密算法，因为不可逆。常见的数据摘要算法位数及转为字符串所占字节数如上表 js默认使用iso8859-1编码，几乎对于编码（utf8、unicode、gbk、ASCII）,英文数字等简单字符（码表中序列0-255）的编码，1字符=1字节 base64编码会把3字节的二进制数据编码为4字节的文本数据，转换过程不足3字节，末尾补足\x00，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码时再去掉。=在URL、Cookie里会造成歧义，所以，有些base64编码后会把=去掉 Md5摘要的字符串长度为32字节，16字节的Md5摘要是取32字节的中间16字节。如a12345678的摘要，32位为：e9bc0e13a8a16cbb07b175d92a113126，16位为：a8a16cbb07b175d9]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot+Mybatis配置多数据源]]></title>
    <url>%2F2017%2F10%2F09%2Fmulti_datasource%2F</url>
    <content type="text"><![CDATA[开发企业级应用程序时常遇到要使用多个服务器上数据库的情况，此时需要配置多个数据源。查阅相关资料，遇到不少坑，亲测如下： 项目目录结构 关键文件pom文件配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.kodgames&lt;/groupId&gt; &lt;artifactId&gt;MultiDataSource&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;MultiDataSource&lt;/name&gt; &lt;description&gt;test Spring boot multi Datasource&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;jarName&gt;MultiDataSource&lt;/jarName&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring Boot web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL JDBC驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.zaxxer/HikariCP --&gt; &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt;*.*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; application.properties配置文件12345678910111213server.port=8095# Primary DataSource configurationdatasource.primary.jdbcUrl=jdbc:mysql://172.16.2.163:8091/club4agency?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falsedatasource.primary.username=****datasource.primary.password=******datasource.primary.driver-class-name=com.mysql.jdbc.Driver# Secondary DataSource configurationdatasource.secondary.jdbcUrl=jdbc:mysql://127.0.0.1/mahjongforagency?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falsedatasource.secondary.username=****datasource.secondary.password=******datasource.secondary.driver-class-name=com.mysql.jdbc.Driver ApplicationConfiguration配置类123456789101112131415161718192021222324252627282930313233343536373839package com.test.multi.component.config;import com.zaxxer.hikari.HikariDataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.sql.DataSource;/** * Created by Bean on 2017/10/9. */@Configuration@MapperScan(value = &quot;com.test.multi.component.dao.dao1&quot;, sqlSessionFactoryRef = &quot;primarySqlSessionFactory&quot;)public class ApplicationConfiguration &#123; @Bean(name = &quot;primaryDatasource&quot;) @Primary @ConfigurationProperties(prefix = &quot;datasource.primary&quot;) public DataSource primaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = &quot;primarySqlSessionFactory&quot;) @Primary public SqlSessionFactory sqlSessionFactory1(@Qualifier(&quot;primaryDatasource&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:ClubDataDaoMapper.xml&quot;)); return bean.getObject(); &#125;&#125; 同样的，ApplicationConfiguration2配置类123456789101112131415161718192021222324252627282930313233343536package com.test.multi.component.config;import com.zaxxer.hikari.HikariDataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.sql.DataSource;/** * Created by Bean on 2017/10/9. */@Configuration@MapperScan(value = &quot;com.test.multi.component.dao.dao2&quot;, sqlSessionFactoryRef = &quot;secondSqlSessionFactory&quot;)public class ApplicationConfiguration2 &#123; @Bean(name = &quot;secondaryDataSource&quot;) @ConfigurationProperties(prefix = &quot;datasource.secondary&quot;) public DataSource secondDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = &quot;secondSqlSessionFactory&quot;) public SqlSessionFactory sqlSessionFactory2(@Qualifier(&quot;secondaryDataSource&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:GmDataDaoMapper.xml&quot;)); return bean.getObject(); &#125;&#125; type(HikariDataSource.class)指定数据源，设置数据库连接池，若无，则数据库默认时间（通常为8小时）无访问会导致连接断开。指定数据源后，配置文件只认jdbcUrl，即datasource.primary.jdbcUrl而不是datasource.primary.url。 ApplicationConfiguration与ApplicationConfiguration2配置类，@MapperScan扫描的域要区分开（不同的包），两个dao文件ClubDataDao与GmDataDao分别操作不同的数据源。 ApplicationConfiguration与ApplicationConfiguration2配置类，sqlSessionFactoryRef参数声明mybatis sqlsessionfactory来源。 @Primary仅注解到单个数据源，作为默认数据源，用作操作频率最高的数据源上（也常用来区分主从数据库，这个与本文无关）。 其他文件ClubDataDao12345678910package com.test.multi.component.dao.dao1;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface ClubDataDao &#123; List&lt;Integer&gt; queryClubManagerIdByAgencyId(int agencyID);&#125; GmDataDao123456789package com.test.multi.component.dao.dao2;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface GmDataDao &#123; Integer queryGroupIdByAgencyId(int agencyID);&#125;` ClubDataDaoMapper.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.test.multi.component.dao.dao1.ClubDataDao&quot;&gt; &lt;select id=&quot;queryClubManagerIdByAgencyId&quot; resultType=&quot;Integer&quot; parameterType=&quot;Integer&quot;&gt; select DISTINCT club_manager_id from club4agency.agency_club_info where club_agency_id=#&#123;agencyID&#125;; &lt;/select&gt;&lt;/mapper&gt; GmDataDaoMapper.xml1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.test.multi.component.dao.dao2.GmDataDao&quot;&gt; &lt;select id=&quot;queryGroupIdByAgencyId&quot; resultType=&quot;int&quot;&gt; select groupId from account where agencyID = #&#123;agencyID&#125;; &lt;/select&gt;&lt;/mapper&gt; CrossOriginFilter12345678910111213141516171819202122232425262728293031package com.test.multi.component.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by Bean on 2017/10/9. */public class CrossOriginFilter implements Filter &#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest) request; HttpServletResponse httpServletResponse = (HttpServletResponse) response; httpServletResponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); chain.doFilter(httpServletRequest, httpServletResponse); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; Swagger21234567891011121314151617181920212223242526272829303132333435363738394041package com.test.multi.component.doc;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * Created by Bean on 2017/10/9. */@Configuration@EnableSwagger2public class Swagger2 &#123; public static Contact contact = new Contact(&quot;MonkeyBean&quot;, &quot;http://hostip:8095/swagger-ui.html&quot;, &quot;monkeybean_zhang@163.com&quot;); @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.test.multi&quot;)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;) .description(&quot;多数据源测试&quot;) .termsOfServiceUrl(&quot;https://www.google.com/&quot;) .contact(contact) .version(&quot;1.0&quot;) .build(); &#125;&#125; 测试类TestController1234567891011121314151617181920212223242526272829303132333435363738394041package com.test.multi.controller;import com.test.multi.component.dao.dao1.ClubDataDao;import com.test.multi.component.dao.dao2.GmDataDao;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.List;/** * Created by Bean on 2017/10/9. */@RequestMapping(path = &quot;test&quot;)@RestControllerpublic class TestController &#123; @Autowired private ClubDataDao clubDataDao; @Autowired private GmDataDao gmDataDao; /** * 测试多数据源 */ @ApiOperation(value = &quot;testMultiDataSource&quot;) @RequestMapping(path = &quot;multi&quot;, method = RequestMethod.GET) public HashMap&lt;String, Object&gt; testMulti(@RequestParam(value = &quot;agentId&quot;) Integer agentId) &#123; HashMap&lt;String, Object&gt; result = new HashMap&lt;&gt;(); List&lt;Integer&gt; managerIdList = clubDataDao.queryClubManagerIdByAgencyId(agentId); result.put(&quot;managerIdList&quot;, managerIdList); Integer groupId = gmDataDao.queryGroupIdByAgencyId(agentId); result.put(&quot;groupId&quot;, groupId); return result; &#125;&#125; 使用swagger2测试如下：]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 阻塞队列实现超时机制]]></title>
    <url>%2F2017%2F08%2F25%2Fblockqueue%2F</url>
    <content type="text"><![CDATA[阻塞队列概念定义：阻塞队列 (BlockingQueue)是Java util.concurrent包下重要的数据结构，BlockingQueue提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。BlockingQueue是个接口，实现有ArrayBlockingQueue、DelayQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue。本文使用ArrayBlockingQueue：有界的阻塞队列，内部实现是将对象放到一个数组中。jdk源码为：12345678public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125; 参数capacity为数组容量；fair为true，插入或删除对象时，按FIFO顺序处理。 阻塞队列工具实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.Map;import java.util.UUID;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.TimeUnit;public class BlockQueueUtil &#123; /** * 阻塞队列超时时间,单位秒 */ private static final int TIMEOUT = 5; /** * 全局MAP，一个UUID标识一个阻塞队列 */ public static Map&lt;UUID, BlockingQueue&gt; msgHdMap = new ConcurrentHashMap&lt;&gt;(); /** * 单例 */ private static BlockQueueUtil bqInstance = null; public static BlockQueueUtil getInstance() &#123; if (bqInstance == null) &#123; bqInstance = new BlockQueueUtil(); &#125; return bqInstance; &#125; /** * 新建阻塞队列，放入全局map中 * @return uuid */ public UUID getMsgMap() &#123; UUID uuid = UUID.randomUUID(); BlockingQueue&lt;String&gt; msgqueue = new ArrayBlockingQueue&lt;String&gt;(3, true); msgHdMap.put(uuid, msgqueue); return uuid; &#125; /** * 获取阻塞队列 * @param uuid */ public BlockingQueue getQueue(UUID uuid) &#123; return msgHdMap.get(uuid); &#125; /** * 入队 */ public void queueIn(UUID uuid, String responseStr) &#123; BlockingQueue&lt;String&gt; msgqueue = msgHdMap.get(uuid); msgqueue.add(responseStr); &#125; /** * 出队 * @param uuid */ public String queueOut(UUID uuid) &#123; BlockingQueue&lt;String&gt; msgqueue = msgHdMap.get(uuid); String tac = null; try &#123; tac = msgqueue.poll(TIMEOUT, TimeUnit.SECONDS); &#125; catch (InterruptedException e) &#123; // 超时 e.printStackTrace(); &#125; finally &#123; // recycle map msgHdMap.remove(uuid); &#125; return tac; &#125;&#125; ConcurrentHashMap的key为唯一标志uuid，value为阻塞队列。上述getMsgMap方法创建容量为3的阻塞队列；出队方法queueOut调用poll方法（检索并删除此队列的头），超时时间设置为5秒。 调用发起阻塞，等待事件：12345678BlockQueueUtil queueUtil = BlockQueueUtil.getInstance();UUID uuid = queueUtil.getMsgMap();String tac = queueUtil.queueOut(uuid);if (tac == null) &#123;System.out.println(&quot;timeout....&quot;);&#125; else &#123;your normal logic balabala&#125; 初始，每个阻塞队列为空，执行出队操作，阻塞直到事件触发或者超时。事件触发：1// 阻塞队列，入队 BlockQueueUtil.getInstance().queueIn(UUID.fromString(json.getString(&quot;uuid&quot;)), json.get(&quot;res&quot;).toString()); 入队后，阻塞队列不为空，queueUtil.queueOut(uuid)被触发，执行后续操作your normal logic balabala。阻塞队列的应用场景为线程间通信（如生产者消费者模式）或为网络通信（socket或http）。]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java过滤Emoji字符]]></title>
    <url>%2F2017%2F08%2F25%2Ffilter_emoji%2F</url>
    <content type="text"><![CDATA[微信昵称支持Emoji表情，存储微信昵称时，若线上mysql编码未采用utfmb4，依然使用utf-8，向数据库写数据时就要过滤掉昵称中的Emoji表情。过滤emoji可选用以下方法： 方法一：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class EmojiFilter &#123; /** * 检测是否有emoji字符 * @param source * @return 一旦含有就抛出 */ public static boolean containsEmoji(String source) &#123; if (source == null || &quot;&quot;.equals(source)) &#123; return false; &#125; int len = source.length(); for (int i = 0; i &lt; len; i++ ) &#123; char codePoint = source.charAt(i); if (isEmojiCharacter(codePoint)) &#123; // do nothing，判断到了这里表明，确认有表情字符 return true; &#125; &#125; return false; &#125; private static boolean isEmojiCharacter(char codePoint) &#123; return (codePoint == 0x0) || (codePoint == 0x9) || (codePoint == 0xA) || (codePoint == 0xD) || ((codePoint &gt;= 0x20) &amp;&amp; (codePoint &lt;= 0xD7FF)) || ((codePoint &gt;= 0xE000) &amp;&amp; (codePoint &lt;= 0xFFFD)) || ((codePoint &gt;= 0x10000) &amp;&amp; (codePoint &lt;= 0x10FFFF)); &#125; /** * 过滤emoji 或者 其他非文字类型的字符 * @param source * @return */ public static String filterEmoji(String source) &#123; if (!containsEmoji(source)) &#123; return source;// 如果不包含，直接返回 &#125; // 到这里铁定包含 StringBuilder buf = null; int len = source.length(); for (int i = 0; i &lt; len; i++ ) &#123; char codePoint = source.charAt(i); if (isEmojiCharacter(codePoint)) &#123; if (buf == null) &#123; buf = new StringBuilder(source.length()); &#125; buf.append(codePoint); &#125; else &#123;&#125; &#125; if (buf == null) &#123; return source;// 如果没有找到 emoji表情，则返回源字符串 &#125; else &#123; if (buf.length() == len) &#123;// 这里的意义在于尽可能少的toString，因为会重新生成字符串 buf = null; return source; &#125; else &#123; return buf.toString(); &#125; &#125; &#125;&#125; 单元测试如下：12345678public void testEmojiFilter1() &#123; boolean expireRight = true; String predictStr = &quot;An awesome string with a few emojis!&quot;; String nickname= &quot;An 😀awesome 😃string with a few 😉emojis!&quot;; String newNickname = EmojiFilter.filterEmoji(nickname); System.out.println(&quot;newNickname: &quot;+newNickname); assertTrue(&quot;newNickname result: &quot; + newNickname, newNickname.equals(predictStr));&#125; 方法二：如果是maven项目，在pom中引入12345&lt;dependency&gt; &lt;groupId&gt;com.vdurmont&lt;/groupId&gt; &lt;artifactId&gt;emoji-java&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 使用库封装的方法：1String resultStr = EmojiParser.removeAllEmojis(str); 简单封装：12345678910111213141516public class EmojiFilterUtil &#123; /** * 检测是否有emoji字符 */ public static boolean containsEmoji(String source) &#123; if (source == null || &quot;&quot;.equals(source)) &#123; return false; &#125; if (source.length() == EmojiParser.removeAllEmojis(source).length()) &#123; return false; &#125; return true; &#125;&#125; EmojiParser提供emoji处理的各种方法，感兴趣自己试下。 方法三（推荐）：过滤utf8mb4中非utf8字符，不仅仅是emoji123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class FilterUtf8Mb4Util &#123; private static Logger logger = LoggerFactory.getLogger(FilterUtf8Mb4Util.class); /** * 过滤非汉字的utf8的字符（包括emoji） * * @param text 原字符串 * @return 过滤后的字符串 */ public static String filterOffUtf8Mb4(String text) &#123; byte[] bytes = new byte[0]; try &#123; bytes = text.getBytes(&quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; logger.error(&quot;filterOffUtf8Mb4 text to bytes, UnsupportedEncodingException: &#123;&#125;&quot;, e); &#125; ByteBuffer buffer = ByteBuffer.allocate(bytes.length); int i = 0; while (i &lt; bytes.length) &#123; short b = bytes[i]; if (b &gt; 0) &#123; buffer.put(bytes[i++]); continue; &#125; b += 256; //去掉符号位 if (((b &gt;&gt; 5) ^ 0x06) == 0) &#123; buffer.put(bytes, i, 2); i += 2; System.out.println(&quot;2&quot;); &#125; else if (((b &gt;&gt; 4) ^ 0x0E) == 0) &#123; System.out.println(&quot;3&quot;); buffer.put(bytes, i, 3); i += 3; &#125; else if (((b &gt;&gt; 3) ^ 0x1E) == 0) &#123; i += 4; System.out.println(&quot;4&quot;); &#125; else if (((b &gt;&gt; 2) ^ 0xBE) == 0) &#123; i += 5; System.out.println(&quot;5&quot;); &#125; else &#123; i += 6; System.out.println(&quot;6&quot;); &#125; &#125; buffer.flip(); try &#123; return new String(buffer.array(), &quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; logger.error(&quot;filterOffUtf8Mb4 result, UnsupportedEncodingException: &#123;&#125;&quot;, e); return &quot;&quot;; &#125; &#125;&#125; 单元测试如下：123456789public class FilterUtf8Mb4UtilTest extends TestCase &#123; public void testFilterOffUtf8Mb4() throws Exception &#123; String illegalStr1 = &quot;An 馃榾awesome 馃槂string with a few 馃槈emojis!&quot;; String illegalStr2 = &quot;\uD83C\uDFFB鎯呫偡&quot;; assertTrue(!FilterUtf8Mb4Util.filterOffUtf8Mb4(illegalStr1).equals(illegalStr1)); assertTrue(!FilterUtf8Mb4Util.filterOffUtf8Mb4(illegalStr2).equals(illegalStr2)); &#125;&#125;]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring使用hibernate-validator对请求参数校验]]></title>
    <url>%2F2017%2F08%2F24%2FreqModel_bean%2F</url>
    <content type="text"><![CDATA[服务端收到通过拦截器的请求后，第一步，即为对请求参数的合法性校验。合法性校验依次为三部分： 参数是否存在 参数类型是否合法 其他复杂校验 一般的参数校验举例如下：1234567891011121314151617181920public HashMap&lt;String, Object&gt; roleInfo(HttpServletRequest request) &#123; HashMap&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); String roleId; try &#123; roleId = request.getParameter(&quot;id&quot;); &#125; catch (Throwable t) &#123; logger.error(&quot;ProxyController roleInfo args error:&quot; + t); result.put(&quot;result&quot;, StatusCode.ILLEGAL_PARAM.getValue()); result.put(&quot;description&quot;, StatusCode.ILLEGAL_PARAM.getDescription()); return result; &#125; if (!LegalUtil.isLegalRoleId(roleId)) &#123; logger.error(&quot;ProxyController roleinfo roleId error:&quot; + roleId); result.put(&quot;result&quot;, StatusCode.ILLEGAL_PARAM.getValue()); result.put(&quot;description&quot;, StatusCode.ILLEGAL_PARAM.getDescription()); return result; &#125; return proxyService.getRoleInfo(Integer.valueOf(request.getSession().getAttribute(&quot;agencyID&quot;).toString()), Integer.valueOf(roleId)); &#125; 如果采用如下方式接受传入参数，看起来好像可以解决校验臃肿的问题：123456789public HashMap&lt;String, Object&gt; roleInfo(@RequestParam(value = &quot;id&quot;) int id) &#123; if (!LegalUtil.isLegalRoleId(roleId)) &#123; logger.error(&quot;ProxyController roleinfo roleId error:&quot; + roleId); result.put(&quot;result&quot;, StatusCode.ILLEGAL_PARAM.getValue()); result.put(&quot;description&quot;, StatusCode.ILLEGAL_PARAM.getDescription()); return result; &#125; return proxyService.getRoleInfo(Integer.valueOf(request.getSession().getAttribute(&quot;agencyID&quot;).toString()), Integer.valueOf(roleId)); &#125; 但是如果参数过多呢，会导致传入参数按个列出显得过长，而是耦合太紧，也无法复用。统一提出为Model类型，使用hibernate-validator校验（hibernate-validator的引入及注解使用参照官方文档），采用bean注入方式调用，使代码看起来不那么臃肿，层次分明，Model大多时候可以复用，如下所示：12345678910111213141516import javax.validation.constraints.NotNull;import javax.validation.constraints.Pattern;public class RoleInfoReq &#123; @Pattern(regexp = &quot;^[1-9]\\d&#123;6,9&#125;$&quot;, message = &quot;用户id不合法&quot;) @NotNull private String id; public Integer getId() &#123; return Integer.valueOf(id); &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 1234//调用public HashMap&lt;String, Object&gt; roleInfo(@Valid RoleInfoReq reqModel, HttpServletRequest request) &#123; return proxyService.getRoleInfo(Integer.valueOf(request.getSession().getAttribute(&quot;agencyID&quot;).toString()), reqModel.getId()); &#125; 有木有觉得很清爽~复杂的例子如下：提出前：1234567891011121314151617181920212223242526272829303132 public HashMap&lt;String, Object&gt; chargeList(HttpServletRequest request, HttpSession session) &#123; HashMap&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); String idStr; String begintime; String endtime;String currentpage;String pagesize;String totalnum;String flag; try &#123; idStr = request.getParameter(&quot;id&quot;); begintime = request.getParameter(&quot;begintime&quot;); endtime = request.getParameter(&quot;endtime&quot;); currentpage = request.getParameter(&quot;currentpage&quot;); pagesize = request.getParameter(&quot;pagesize&quot;); totalnum = request.getParameter(&quot;totalnum&quot;); flag = request.getParameter(&quot;flag&quot;); &#125; catch (Throwable t) &#123; logger.error(&quot;ChargeController player chargeList args error:&quot; + t); result.put(&quot;result&quot;, StatusCode.ILLEGAL_PARAM.getValue()); result.put(&quot;description&quot;, StatusCode.ILLEGAL_PARAM.getDescription()); return result; &#125; if (!LegalUtil.isLegalIdIncludeZero(idStr) || !LegalUtil.isLegalDate(begintime) || !LegalUtil.isLegalDate(endtime) || !LegalUtil.isDigital(currentpage) || !LegalUtil.isDigital(pagesize) || !LegalUtil.isDigital(totalnum) || !LegalUtil.isDigital(flag)) &#123; result.put(&quot;result&quot;, StatusCode.ILLEGAL_PARAM.getValue()); result.put(&quot;description&quot;, StatusCode.ILLEGAL_PARAM.getDescription()); return result; &#125; 吧啦吧啦。。。 咕噜咕噜。。。 &#125; 提出后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import javax.validation.constraints.Max;import javax.validation.constraints.NotNull;import javax.validation.constraints.Pattern;public class ChargeRecordsCardGivePlayerReq &#123; private final String dateformat = &quot;^(([0-9]&#123;3&#125;[1-9]|[0-9]&#123;2&#125;[1-9][0-9]|[0-9][1-9][0-9]&#123;2&#125;|[1-9][0-9]&#123;3&#125;)-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]&#123;2&#125;)(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29)$&quot;; private final String isDigit = &quot;^[0-9]*$&quot;; /** * 7-10位正整数或0 */ @Pattern(regexp = &quot;^([1-9]\\d&#123;6,9&#125;)|(0)$&quot;, message = &quot;用户id不合法&quot;) @NotNull private String id; /** * 时间格式必须为YYYY-MM-DD */ @Pattern(regexp = dateformat, message = &quot;时间格式不合法&quot;) @NotNull private String begintime; @Pattern(regexp = dateformat, message = &quot;时间格式不合法&quot;) @NotNull private String endtime; @Pattern(regexp = isDigit, message = &quot;当前页，格式不合法&quot;) @Max(Integer.MAX_VALUE) @NotNull private String currentpage; @Pattern(regexp = isDigit, message = &quot;每页记录数，格式不合法&quot;) @Max(Integer.MAX_VALUE) @NotNull private String pagesize; @Pattern(regexp = isDigit, message = &quot;总记录数，格式不合法&quot;) @Max(Integer.MAX_VALUE) @NotNull private String totalnum; @Pattern(regexp = &quot;^1|2$&quot;, message = &quot;房卡类型不合法&quot;) @NotNull private String flag; public String getBegintime() &#123; return begintime; &#125; public void setBegintime(String begintime) &#123; this.begintime = begintime; &#125; public String getEndtime() &#123; return endtime; &#125; public void setEndtime(String endtime) &#123; this.endtime = endtime; &#125; public Integer getCurrentpage() &#123; return Integer.valueOf(currentpage); &#125; public void setCurrentpage(String currentpage) &#123; this.currentpage = currentpage; &#125; public Integer getPagesize() &#123; return Integer.valueOf(pagesize); &#125; public void setPagesize(String pagesize) &#123; this.pagesize = pagesize; &#125; public Integer getTotalnum() &#123; return Integer.valueOf(totalnum); &#125; public void setTotalnum(String totalnum) &#123; this.totalnum = totalnum; &#125; public Integer getFlag() &#123; return Integer.valueOf(flag); &#125; public void setFlag(String flag) &#123; this.flag = flag; &#125; public Integer getId() &#123; return Integer.valueOf(id); &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 12345678//调用public HashMap&lt;String, Object&gt; chargeList(@Valid ChargeRecordsCardGivePlayerReq reqModel, HttpSession session) &#123; if (reqModel.getFlag() == 1) &#123; return chargeService.getGivePlayerRecords(Integer.valueOf(session.getAttribute(&quot;agencyID&quot;).toString()), reqModel.getId(), reqModel.getBegintime(), reqModel.getEndtime(), reqModel.getCurrentpage(), reqModel.getPagesize(), reqModel.getTotalnum()); &#125; else &#123; return chargeService.getGiveManagerRecord(Integer.valueOf(session.getAttribute(&quot;agencyID&quot;).toString()), reqModel.getId(), reqModel.getBegintime(), reqModel.getEndtime(), reqModel.getCurrentpage(), reqModel.getPagesize(), reqModel.getTotalnum()); &#125; &#125; 若参数校验不合法，返回状态码400，出错时间，错误原因等详细信息，对接良好。注意，若为post请求，使用注解@Valid @ModelAttribute1public HashMap&lt;String, Object&gt; chargeList(@Valid @ModelAttribute ChargeRecordsCardGivePlayerReq reqModel, HttpSession session) &#123;&#125; 若为get请求，使用注解@Valid1public HashMap&lt;String, Object&gt; chargeList(@Valid ChargeRecordsCardGivePlayerReq reqModel, HttpSession session) &#123;&#125; 模拟单纯发http请求，不走浏览器，使用curl或者postman，curl可以看到请求的详细过程，postman图形界面且有历史记录，开发中推荐使用curl，两者皆可。如以上的chargeList函数的参数校验，模拟请求：1234567891011121314151617#正确输入curl -v http://127.0.0.1:8091/guiyang/agentboot/charge/records/card/give/player?id=1234567&quot;&amp;&quot;begintime=2017-01-01&quot;&amp;&quot;endtime=2018-01-01&quot;&amp;&quot;currentpage=1&quot;&amp;&quot;pagesize=1&quot;&amp;&quot;totalnum=1&quot;&amp;&quot;flag=1#缺少参数curl -v http://127.0.0.1:8091/guiyang/agentboot/charge/records/card/give/player?id=1234567&quot;&amp;&quot;begintime=2017-01-01&quot;&amp;&quot;endtime=2018-01-01&quot;&amp;&quot;pagesize=1&quot;&amp;&quot;totalnum=1&quot;&amp;&quot;flag=1#用户id不合法curl -v http://127.0.0.1:8091/guiyang/agentboot/charge/records/card/give/player?id=124534567&quot;&amp;&quot;begintime=2017-01-01&quot;&amp;&quot;endtime=2018-01-01&quot;&amp;&quot;currentpage=1&quot;&amp;&quot;pagesize=1&quot;&amp;&quot;totalnum=1&quot;&amp;&quot;flag=1#时间格式不合法curl -v http://127.0.0.1:8091/guiyang/agentboot/charge/records/card/give/player?id=1234567&quot;&amp;&quot;begintime=2017-01-01&quot;&amp;&quot;endtime=2018-0101&quot;&amp;&quot;currentpage=1&quot;&amp;&quot;pagesize=1&quot;&amp;&quot;totalnum=1&quot;&amp;&quot;flag=1#总数量格式不合法curl -v http://127.0.0.1:8091/guiyang/agentboot/charge/records/card/give/player?id=1234567&quot;&amp;&quot;begintime=2017-01-01&quot;&amp;&quot;endtime=2018-01-01&quot;&amp;&quot;currentpage=-1&quot;&amp;&quot;pagesize=1&quot;&amp;&quot;totalnum=1&quot;&amp;&quot;flag=1#卡类型不合法curl -v http://127.0.0.1:8091/guiyang/agentboot/charge/records/card/give/player?id=1234567&quot;&amp;&quot;begintime=2017-01-01&quot;&amp;&quot;endtime=2018-01-01&quot;&amp;&quot;currentpage=1&quot;&amp;&quot;pagesize=1&quot;&amp;&quot;totalnum=1&quot;&amp;&quot;flag=0 请求格式统一提出Model，同样地，返回格式也可统一格式，提出Model，这块不多介绍，感兴趣的尝试一下。]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中RSA的使用]]></title>
    <url>%2F2017%2F08%2F20%2Frsa_java%2F</url>
    <content type="text"><![CDATA[RSA为非对称加密，根据应用场景不同，分如下两种：1.签名：使用私钥加密，公钥解密。用于验证私钥持有者的身份，防止私钥所有者发布的内容被篡改，但是公钥一般是公开的，所以无法保证加密内容不被其他人获得。2.加密：公钥加密，私钥解密。加密内容无法被他人获得，但是信息可能被他人篡改伪造。以下为Java中RSA算法的实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193public class RSACoder &#123; public static final String KEY_ALGORITHM = &quot;RSA&quot;; public static final String SIGNATURE_ALGORITHM = &quot;MD5withRSA&quot;; private static final String PUBLIC_KEY = &quot;RSAPublicKey&quot;; private static final String PRIVATE_KEY = &quot;RSAPrivateKey&quot;; /** * 初始化密钥 * * @return * @throws Exception */ public static Map&lt;String, Object&gt; initKey() throws Exception &#123; KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM); keyPairGen.initialize(512); KeyPair keyPair = keyPairGen.generateKeyPair(); // 公钥 RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); // 私钥 RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, Object&gt; keyMap = new HashMap&lt;String, Object&gt;(2); keyMap.put(PUBLIC_KEY, publicKey); keyMap.put(PRIVATE_KEY, privateKey); return keyMap; &#125; /** * 取得私钥 * * @param keyMap * @return * @throws Exception */ public static String getPrivateKey(Map&lt;String, Object&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PRIVATE_KEY); return encryptHex(key.getEncoded()); &#125; /** * 取得公钥 * * @param keyMap * @return * @throws Exception */ public static String getPublicKey(Map&lt;String, Object&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PUBLIC_KEY); return encryptHex(key.getEncoded()); &#125; /** * from koduser 加密&lt;br&gt; * 用私钥加密 * * @param data * @param key * @return * @throws Exception */ public static byte[] encryptByPrivateKey(byte[] data, String key) throws Exception &#123; // 对密钥解密 byte[] keyBytes = decryptHex(key); // 取得私钥 PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, privateKey); return cipher.doFinal(data); &#125; /** * 用私钥解密 * * @param data * @param key * @return * @throws Exception */ public static byte[] decryptByPrivateKey(byte[] data, String key) throws Exception &#123; byte[] keyBytes = decryptHex(key); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateKey); return cipher.doFinal(data); &#125; /** * 用公钥加密 * * @param data * @param key * @return * @throws Exception */ public static byte[] encryptByPublicKey(byte[] data, String key) throws Exception &#123; byte[] keyBytes = decryptHex(key); // 取得公钥 X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicKey = keyFactory.generatePublic(x509KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, publicKey); return cipher.doFinal(data); &#125; /** * 用公钥解密 * * @param data * @param key * @return * @throws Exception */ public static byte[] decryptByPublicKey(byte[] data, String key) throws Exception &#123; byte[] keyBytes = decryptHex(key); // 取得公钥 X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicKey = keyFactory.generatePublic(x509KeySpec); // 对数据解密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, publicKey); return cipher.doFinal(data); &#125; /** * 用私钥来签名 * * @param data * @param privateKey * @return * @throws Exception */ public static String sign(byte[] data, String privateKey) throws Exception &#123; byte[] keyBytes = decryptHex(privateKey); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initSign(priKey); signature.update(data); return encryptHex(signature.sign()); &#125; /** * 用公钥来验签 * * @param data * @param publicKey * @param sign * @return * @throws Exception */ public static boolean verify(byte[] data, String publicKey, String sign) throws Exception &#123; byte[] keyBytes = decryptHex(publicKey); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PublicKey pubKey = keyFactory.generatePublic(keySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initVerify(pubKey); signature.update(data); return signature.verify(decryptHex(sign)); &#125;&#125; 测试以上方法如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 私钥签名，公钥验签 */public void testSignVerify() throws Exception &#123; Map&lt;String, Object&gt; key = RSACoder.initKey(); String publicKey = RSACoder.getPublicKey(key); String privateKey = RSACoder.getPrivateKey(key); String data = &quot;testData&quot;; String sign = RSACoder.sign(data.getBytes(), privateKey); RSACoder.verify(data.getBytes(), publicKey, sign); assertTrue(RSACoder.verify(data.getBytes(), publicKey, sign));&#125;/** * 私钥加密，公钥解密 * * @throws Exception */public void testPrivateEncryt() throws Exception &#123; Map&lt;String, Object&gt; key = RSACoder.initKey(); String publicKey = RSACoder.getPublicKey(key); String privateKey = RSACoder.getPrivateKey(key); String data = &quot;testDataPrivate&quot;; byte[] encryDataByte = RSACoder.encryptByPrivateKey(data.getBytes(), privateKey); byte[] decryDataByte = RSACoder.decryptByPublicKey(encryDataByte, publicKey); String decryData = new String(decryDataByte); System.out.println(decryData); assertTrue(decryData.equals(data));&#125;/** * 公钥加密，私钥解密 */public void testPublicEncryt() throws Exception &#123; Map&lt;String, Object&gt; key = RSACoder.initKey(); String publicKey = RSACoder.getPublicKey(key); String privateKey = RSACoder.getPrivateKey(key); String data = &quot;testDataPublic&quot;; byte[] encryDataByte = RSACoder.encryptByPublicKey(data.getBytes(), publicKey); byte[] decryDataByte = RSACoder.decryptByPrivateKey(encryDataByte, privateKey); String decryData = new String(decryDataByte); System.out.println(decryData); assertTrue(decryData.equals(data));&#125; 一般使用私钥签名，将签名内容一同发送给接收者验签，这样保证了发送者的身份有效性（服务器A给服务器B发送内容，使用服务器A的公钥私钥）。如果公钥不对外暴露，服务器之间采用相互信任的机制，各自保留对方的公钥，那么可采取公钥加密私钥解密的方式（服务器A给服务器B发送内容，使用服务器B的公钥私钥）。注：加解密参数及结果经常为字节数组，此时涉及字节数组与字符串的比较，那么就要转换类型。String a转byte[] b为方法为a.getBytes(),getBytes()参数为编码类型，无参则使用环境编码（Charset.defaultCharset()查看当前系统编码），从jdk源码看，若编码不支持，则使用ISO-8859-1编码，建议制定兼容的UTF-8编码。byte[] b转String a的方法为new String(b),同样可指定编码，切勿使用b.toString(),字节数组未覆盖Object的toString方法，toString()获得的是内存地址（也非实际物理地址，只是约定为getClass().getName() + “@” + Integer.toHexString(hashCode())）。 拓展推荐一个Java工具类，功能强大，其中封装了各种加解密方法。简单测试其AES算法为123456789public void testAESHex() throws UnsupportedEncodingException &#123; String content = &quot;justForTest&quot;; byte[] key = SecureUtil.generateKey(SymmetricAlgorithm.AES.getValue()).getEncoded(); System.out.println(&quot;key length: &quot; + key.length); SymmetricCrypto aes = new SymmetricCrypto(SymmetricAlgorithm.AES, key); String encryptHex = aes.encryptHex(content); String decrypt = aes.decryptStr(encryptHex, CharsetUtil.CHARSET_UTF_8); assertTrue(decrypt.equals(content));&#125; aes加解密encryptHex对应decryptStr，encrypt对应decrypt，以上key为工具类生成的，若自己指定key，则key必须为16、24、32位等，如下ct为毫秒级的Unix时间戳，只有13位，为凑足16位，随机加上3位，如”123”:12345678910public void testAES1() throws UnsupportedEncodingException &#123; String content = &quot;justForTest&quot;; long ct = System.currentTimeMillis(); //13位 String key = String.valueOf(ct) + &quot;123&quot;; SymmetricCrypto aes = new SymmetricCrypto(SymmetricAlgorithm.AES, key.getBytes(&quot;ISO-8859-1&quot;)); byte[] encrypt = aes.encrypt(content); byte[] decrypt = aes.decrypt(encrypt); String result = new String(decrypt, &quot;ISO-8859-1&quot;); assertTrue(result.equals(content));&#125;]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql分页]]></title>
    <url>%2F2017%2F08%2F17%2Fpaging_mysql%2F</url>
    <content type="text"><![CDATA[mysql使用limit，offset实现分页。limt 3 offset 5 效果同 limit 5,3都表示偏移5，从第6条开始读，读3条记录。示例如下:12345678910selectdate_format(createTime, &quot;%Y-%m-%d %T&quot;) as time,buyerId,commissionfrompartner_commission_recordwheredate_format(createTime, &quot;%Y-%m-%d&quot;) between #&#123;date_from&#125; and #&#123;date_to&#125;and agencyId = #&#123;agencyId&#125; and (rebateLV=1 or rebateLV=2) and isCancel=0order bycreateTime desclimit #&#123;limit&#125; offset #&#123;offset&#125;; ORM使用Mybatis则建议使用Mybatis的动态sql语句，通过标签实现不同情形的sql复用。示例如下:12345678910111213141516171819&lt;select id=&quot;addCardPlayerRecord&quot; parameterType=&quot;HashMap&quot; resultType=&quot;HashMap&quot;&gt; select playerID,amount,date_format(time, &quot;%Y-%m-%d %T&quot;) as time from add_player_card_log where agency = #&#123;agencyID&#125; &lt;if test=&quot;null!=playerID&quot;&gt; and playerID = #&#123;playerID&#125; &lt;/if&gt; &lt;if test=&quot;null!=date_from and null!=date_to&quot;&gt; and date_format(time, &quot;%Y-%m-%d&quot;) between #&#123;date_from&#125; and #&#123;date_to&#125; &lt;/if&gt; order by add_player_card_log.time desc &lt;if test=&quot;null!=limit and null!=offset&quot;&gt; limit #&#123;limit&#125; offset #&#123;offset&#125;; &lt;/if&gt;&lt;/select&gt;]]></content>
      <tags>
        <tag>技术</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql插入测试数据示例]]></title>
    <url>%2F2017%2F08%2F08%2Fmysql_insert%2F</url>
    <content type="text"><![CDATA[在接口自测及联调阶段，需要伪造数据供测试使用，以如下简单程序示例循环插入数据：1234567891011121314drop procedure if exists test_insert;DELIMITER //create procedure test_insert()begindeclare i int;set i = 1000;while i&lt;1050 doinsert into account(agencyID,userName,referrer,account,weixin,card,createTime,verification,status,payStatus,firstLoginStatus) values(i,concat(&quot;test&quot;,i),2002428,concat(18841000,i),concat(&quot;testweixin&quot;,i),1000,date(now()),1,3,1,1);set i = i+1;end while;end //DELIMITER ;call test_insert(); 注释：DELIMITER作用是告诉Mysql解释器，该段命令是否已经结束。默认情况下，delimiter是分号;mysql一遇到分号，就要自动执行，所以需要事先把delimiter换成其它符号，如//或$$，最后再重置为默认值。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简谈mysql中utf8mb4]]></title>
    <url>%2F2017%2F08%2F06%2Futf8mb4%2F</url>
    <content type="text"><![CDATA[最近开发遇到当Mysql存储微信昵称,而微信昵称有emoji表情符号时，数据库存储数据出现乱码。原因是mysql支持的utf8编码最大长度为3字节，如果遇4字节的宽字符(emoji表情符号、不常用的汉字、新增的Unicode字符等)就会插入异常。Mysql在5.5.3之后增加utf8mb4（most bytes 4）编码,专门用于兼容四字节的unicode，一般情况。为了节省空间，使用utf8即可，但是建议使用utf8mb4。 Linux下更改mysql编码方式使用Linux的发行版本为Centos 首先查看mysql版本，是否支持utf8mb4（5.5.3版本及以上）。查看版本简易方法：终端下：mysql -Vmysql下:status; 或 select version(); 修改mysql配置文件修改my.conf(windows下为my.ini)修改前后的配置文件及系统编码分别如下：修改前编码：修改前配置文件：修改后的编码：修改后的配置文件： 修改database、table及column的字符集123ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;ALTER TABLE table_name CHANGE column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 重启mysql1service mysql restart 或 systemctl restart mysqld.service 若更新sql，指定编码方式为utf8mb41mysql -uyourName -pyourPassword --default-character-set=utf8mb4 mahjongforagency &lt; /root/update.sql]]></content>
      <tags>
        <tag>技术</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos网络时间同步]]></title>
    <url>%2F2017%2F07%2F30%2Fcentos_ntpd%2F</url>
    <content type="text"><![CDATA[场景系统为Centos6或7, 多个服务器之间存在时间合法性验证，由于各服务器时间不统一，验证不通过。 解决方法执行如下命令矫正本地时间，网络同步12345678# 安装网络时间协议yum install ntp# 开启ntp daemon，开机自启动chkconfig ntpd on# 同步系统时间，可选任意可靠的时间服务器，这里用的是pool.ntp.orgntpdate pool.ntp.org# 启动时间同步协议service ntpd start]]></content>
      <tags>
        <tag>技术</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java解析xml]]></title>
    <url>%2F2017%2F07%2F08%2Fjava_xml%2F</url>
    <content type="text"><![CDATA[如下xml为例：123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;datasoruce&gt; &lt;property name=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;url&quot;&gt; jdbc:mysql://127.0.0.1:3306/poker?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=true &lt;/property&gt; &lt;property name=&quot;username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt;&lt;/datasoruce&gt; 解析引入dom4j,这里使用的为2.0.0版本，具体文档到社区查看，github已有最新2.0.1版本，dom4j更新很慢，也可以说比较稳定。import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;日志输出使用：import org.slf4j.Logger;import org.slf4j.LoggerFactory;解析类如下：12345678910111213141516171819202122232425262728public class XmlParser&#123; private static final Logger logger = LoggerFactory.getLogger(XmlParser.class); public static HashMap&lt;String, String&gt; parse(InputStream inputStream) &#123; SAXReader reader = new SAXReader(); Document document = null; try &#123; document = reader.read(inputStream); &#125; catch (DocumentException e) &#123; logger.error(&quot;parse xml error: &#123;&#125;&quot;, e); &#125; Element root = document.getRootElement(); List nodes = root.elements(&quot;property&quot;); Iterator&lt;Element&gt; it = nodes.iterator(); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); while (it.hasNext()) &#123; Element element = it.next(); map.put(element.attribute(&quot;name&quot;).getText(), element.getStringValue()); &#125; return map; &#125;&#125; 外层调用：12InputStream inputStream = DbManager.class.getResourceAsStream(&quot;/datasource.xml&quot;);HashMap&lt;String, String&gt; map = XmlParser.parse(inputStream); 另外，如果验证拿到xml的合法性，则如下，将输入流解析为字符流输出，引入com.google.common.io.CharStreams;12345678910// 输出连接数据库的配置文件InputStream inputStream = DbManager.class.getResourceAsStream(&quot;/datasource.xml&quot;);try &#123; String text = CharStreams.toString(new InputStreamReader(inputStream, &quot;UTF-8&quot;)); logger.info(&quot;dataSource.xml str: \n&#123;&#125;&quot;,text);&#125; catch (IOException e) &#123; logger.error(&quot;dataSource.xml IOException e -&gt;&#123;&#125;&quot;, e);&#125;inputStream = DbManager.class.getResourceAsStream(&quot;/datasource.xml&quot;);HashMap&lt;String, String&gt; map = XmlParser.parse(inputStream); String text = CharStreams.toString(new InputStreamReader(inputStream, “UTF-8”));已经将输入流读取完毕,已到流的结尾，不可直接再次使用。需重新获取inputStream = DbManager.class.getResourceAsStream(“/datasource.xml”); 补充，上一步执行了两次inputStream = DbManager.class.getResourceAsStream(“/datasource.xml”);效率很低,看起来也很傻。又看了下inputStream有mark/reset方法，解决了我的问题。如下：1234567891011inputStream = DbManager.class.getResourceAsStream(&quot;/datasource.xml&quot;);try &#123; // inputStream.markSupported(); inputStream.mark(inputStream.available()); String text = CharStreams.toString(new InputStreamReader(inputStream, &quot;UTF-8&quot;)); inputStream.reset(); logger.info(&quot;dataSource.xml str: \n&#123;&#125;&quot;,text);&#125; catch (IOException e) &#123; logger.error(&quot;dataSource.xml IOException e -&gt;&#123;&#125;&quot;, e);&#125;HashMap&lt;String, String&gt; map = XmlParser.parse(inputStream); InputStream本身提供三个接口 markSupported()；InputStream是否支持mark，默认不支持 mark(int readLimit);用于标记当前位置，在读取一定数量的数据(小于readlimit的数据)后使用reset可以回到mark标记的位置。 reset()；回到mark标记位置。 子类需要支持mark必须重写这三个方法。]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js解析xml]]></title>
    <url>%2F2017%2F07%2F06%2Fjs_xml%2F</url>
    <content type="text"><![CDATA[js解析xml字符串示例为DOMParser.parseFromString()的简单使用。以下用到ES6的多行字符串，注意包含str值的两个点是Tab键上面、数字键1左边的按键，而不是单引号。1234567891011121314151617181920212223242526272829303132333435function testXmlStr()&#123; var str = `&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt; &lt;province name=&quot;北京直辖市&quot;&gt; &lt;city&gt;昌平区&lt;/city&gt; &lt;city&gt;朝阳区&lt;/city&gt; &lt;city&gt;崇文区&lt;/city&gt; &lt;city&gt;大兴区&lt;/city&gt; &lt;city&gt;东城区&lt;/city&gt; &lt;city&gt;房山区&lt;/city&gt; &lt;city&gt;丰台区&lt;/city&gt; &lt;city&gt;海淀区&lt;/city&gt; &lt;city&gt;怀柔区&lt;/city&gt; &lt;city&gt;门头沟区&lt;/city&gt; &lt;city&gt;密云区&lt;/city&gt; &lt;city&gt;平谷区&lt;/city&gt; &lt;city&gt;石景山区&lt;/city&gt; &lt;city&gt;顺义区&lt;/city&gt; &lt;city&gt;通州区&lt;/city&gt; &lt;city&gt;西城区&lt;/city&gt; &lt;city&gt;宣武区&lt;/city&gt; &lt;city&gt;延庆区&lt;/city&gt; &lt;/province&gt;&lt;/root&gt;`; //创建文档对象 var parser=new DOMParser(); var xmlDoc=parser.parseFromString(str,&quot;text/xml&quot;); //提取数据 var countrys = xmlDoc.getElementsByTagName(&apos;city&apos;); var arr = []; //输出数据 for (var i = 0; i &lt; countrys.length; i++) &#123; arr.push(countrys[i].textContent); &#125;; console.log(arr);&#125; js解析本地xml文件要解析的xml文件部分数据如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt; &lt;province name=&quot;北京直辖市&quot;&gt; &lt;city&gt;昌平区&lt;/city&gt; &lt;city&gt;朝阳区&lt;/city&gt; &lt;city&gt;崇文区&lt;/city&gt; &lt;city&gt;大兴区&lt;/city&gt; &lt;city&gt;东城区&lt;/city&gt; &lt;city&gt;房山区&lt;/city&gt; &lt;city&gt;丰台区&lt;/city&gt; &lt;city&gt;海淀区&lt;/city&gt; &lt;city&gt;怀柔区&lt;/city&gt; &lt;city&gt;门头沟区&lt;/city&gt; &lt;city&gt;密云区&lt;/city&gt; &lt;city&gt;平谷区&lt;/city&gt; &lt;city&gt;石景山区&lt;/city&gt; &lt;city&gt;顺义区&lt;/city&gt; &lt;city&gt;通州区&lt;/city&gt; &lt;city&gt;西城区&lt;/city&gt; &lt;city&gt;宣武区&lt;/city&gt; &lt;city&gt;延庆区&lt;/city&gt; &lt;/province&gt; &lt;province name=&quot;上海直辖市&quot;&gt; &lt;city&gt;宝山区&lt;/city&gt; &lt;city&gt;长宁区&lt;/city&gt; &lt;city&gt;崇明县&lt;/city&gt; &lt;city&gt;奉贤区&lt;/city&gt; &lt;city&gt;虹口区&lt;/city&gt; &lt;city&gt;黄浦区&lt;/city&gt; &lt;city&gt;嘉定区&lt;/city&gt; &lt;city&gt;金山区&lt;/city&gt; &lt;city&gt;静安区&lt;/city&gt; &lt;city&gt;卢湾区&lt;/city&gt; &lt;city&gt;闵行区&lt;/city&gt; &lt;city&gt;南汇区&lt;/city&gt; &lt;city&gt;浦东新区&lt;/city&gt; &lt;city&gt;普陀区&lt;/city&gt; &lt;city&gt;青浦区&lt;/city&gt; &lt;city&gt;松江区&lt;/city&gt; &lt;city&gt;徐汇区&lt;/city&gt; &lt;city&gt;杨浦区&lt;/city&gt; &lt;city&gt;闸北区&lt;/city&gt; &lt;/province&gt;&lt;/root&gt; 解析内容放到二维数组中，代码如下：123456789101112131415161718192021222324if (window.XMLHttpRequest)&#123; // code for IE7+, Firefox, Chrome, Opera, Safarixmlhttp=new XMLHttpRequest();&#125;else&#123; // code for IE6, IE5xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;xmlhttp.open(&quot;GET&quot;,&quot;example.xml&quot;,false);xmlhttp.send();xmlDoc=xmlhttp.responseXML;console.log(xmlDoc);var arr=[];var x=xmlDoc.getElementsByTagName(&quot;province&quot;);var arr=new Array(x.length);Array.from(x).forEach( function(el, index) &#123; if(arr[index]==undefined)&#123; arr[index]=[]; &#125; Array.from(el.getElementsByTagName(&quot;city&quot;)).forEach(function (e,i) &#123; arr[index].push(e.childNodes[0].nodeValue); &#125;)&#125;);console.log(arr); open方法三个参数分别为http请求方式、请求地址、同步（false,阻塞，不使用异步）还是异步（true）; send方法用于post传递参数，本例未用到，默认为null。如xmlhttp.send(“data=data&amp;data2=data2”); responseXML属性返回XML文档对象; xmlDoc.getElementsByTagName得到的是Dom对象，不可使用forEach,使用Array.from(x)创建数组实例; Array.from()的参数为类似数组或者可迭代的对象，只要有length属性的方法均可作为参数; js解析ajax请求返回的文档对象使用jquery的ajax方法，将返回对象解析到json中，如下：1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;解析xml文件&lt;/title&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt;console.log(&apos;****************************************************************&apos;);$.ajax(&#123; type: &quot;GET&quot;, url: &quot;https://pay.heepay.com/API/PayTransit/QueryProvincesAndCities.aspx&quot;, dataType: &quot;xml&quot;, success: function (ResponseText) &#123; var json=&#123;&#125;; Array.from(ResponseText).forEach( function(el, index) &#123; if(json[el.getAttribute(&apos;name&apos;)]==undefined)&#123; json[el.getAttribute(&apos;name&apos;)]=[]; &#125; Array.from(el.getElementsByTagName(&quot;city&quot;)).forEach(function (e,i) &#123; json[el.getAttribute(&apos;name&apos;)].push(e.childNodes[0].nodeValue); &#125;) &#125;); console.log(json); &#125;&#125;);&lt;/script&gt;&lt;/html&gt; 控制台查看返回如下，跨域，不可访问。12XMLHttpRequest cannot loadNo &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;null&apos; is therefore not allowed access. 而用java，httpClient请求（用的Apache HttpClient 4.5.2），可以拿到该资源。浏览器输入网址可以访问，用postMan也可访问，唯有ajax不可访问。于是查了下，才想起来浏览器的同源策略导致Ajax只能同源使用。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.IOException;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpOptions;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;public class TestMain&#123; public static void main(String[] args)&#123; String url = &quot;https://pay.heepay.com/API/PayTransit/QueryProvincesAndCities.aspx&quot;; String result = doGet(url); System.out.println(result); &#125; public static String doGet(String url) &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); CloseableHttpResponse response = null; String result = &quot;&quot;; HttpGet httpGet = new HttpGet(url); try &#123; response = httpclient.execute(httpGet); if (response.getStatusLine().getStatusCode() == 200) &#123; HttpEntity entity = response.getEntity(); result = EntityUtils.toString(entity); EntityUtils.consume(entity); &#125; &#125; catch (Exception e) &#123; e.getStackTrace(); &#125; finally &#123; try &#123; if (response != null) response.close(); httpclient.close(); &#125; catch (IOException e) &#123; &#125; &#125; return result; &#125;&#125; 浏览器的同源安全策略同源安全策略是浏览器最核心也是最基本的安全机制。同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键安全机制，为了保证用户信息的安全，防止恶意的网站窃取数据。比如A网站设置的 Cookie，由于同源策略，B网站就不能打开或修改。设想如下情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，信息就会泄漏，其他网站就可以冒充用户，为所欲为。同源的定义： 协议相同 域名相同 端口相同 跨域需要双端协作，本文用的接口没有服务端控制权，只有前端单方面无法解决跨域问题，ajax不可请求该资源。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-boot集成Swagger2]]></title>
    <url>%2F2017%2F07%2F05%2Fswagger2%2F</url>
    <content type="text"><![CDATA[Swagger用于定义API文档，实现前后端开发分离，测试时不再需要浏览器输入URL访问Controller。对于post请求，无需使用postman模拟，在接口文档中填参数，可直接模拟发请求。本文介绍Swagger2的引入及常用注解。 pom.xml中添加依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; 引入Swagger2新建类，注解方式引入Swagger212345678910111213141516171819202122232425@Configuration@EnableSwagger2public class Swagger2 &#123; public static Contact contact = new Contact(&quot;引入swagger2&quot;,&quot;http://monkeybean.cn/&quot;,&quot;monkeybean_zhang@163.com&quot;); @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.kodgames.pokeragent&quot;)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;) .description(&quot;swagger2 接口文档&quot;) .termsOfServiceUrl(&quot;http://monkeybean.cn/&quot;) .contact(contact) .version(&quot;1.0&quot;) .build(); &#125;&#125; Controller中添加注解举例：1234567891011/** * 查询用户是否为代理 */@ApiOperation(value=&quot;查询用户是否为代理商&quot;)@ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户id&quot;, required = true, dataType = &quot;int&quot;,paramType = &quot;query&quot;)@ApiResponses(value = &#123;@ApiResponse(code = -1,message = &quot;用户不存在&quot;),@ApiResponse(code = -20,message = &quot;代理商被封号&quot;),@ApiResponse(code = -23,message = &quot;当前用户已提交申请，且申请处于审核中&quot;)&#125;)@RequestMapping(path = &quot;agent/is_agent&quot;, method = RequestMethod.GET)public HashMap&lt;String, Object&gt; isAgent(@RequestParam(value = &quot;id&quot;) int accountId)&#123; return service.isAgent(accountId);&#125; 示例说明：1.@ApiOperation：用在方法上，说明方法的作用，再比如：1@ApiOperation(value=&quot;查询返还明细&quot;, notes=&quot;下级id不支持模糊搜索&quot;) 2.@ApiImplicitParams：用在方法上包含一组参数说明如：123456@ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户id&quot;, required = true, dataType = &quot;int&quot;,paramType = &quot;query&quot;), @ApiImplicitParam(name = &quot;phone_number&quot;, value = &quot;手机号&quot;, required = true, dataType = &quot;string&quot;,paramType = &quot;query&quot;), @ApiImplicitParam(name = &quot;validcode&quot;, value = &quot;验证码&quot;, required = true, dataType = &quot;string&quot;,paramType = &quot;query&quot;), @ApiImplicitParam(name = &quot;advantages&quot;, value = &quot;个人优势&quot;, required = true, dataType = &quot;string&quot;,paramType = &quot;query&quot;) &#125;) 3.@ApiImplicitParam：用在@ApiImplicitParams注解中，对单个参数进行说明 name：参数名 value：参数含义 required：参数是否必须传 defaultValue：参数默认值 dataType：参数类型（对象类型，基本类型要使用包装类） paramType：参数放在哪个位置 header–&gt;放在header中，请求参数获取方法：@RequestHeader query–&gt;放在url中，请求参数获取方法：@RequestParam path（用于restful接口）–&gt;请求参数获取方法：@PathVariable，示例如下，重点为{} 123456@ApiOperation(value=&quot;获取用户详细信息&quot;, notes=&quot;根据url的id来获取用户详细信息&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;long&quot;, paramType = &quot;path&quot;) @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; return users.get(id); &#125; body及form不常用 @ApiResponses：用于表示一组响应 @ApiResponse：用在@ApiResponses中，表示单个错误响应信息 code：错误码 message：错误码含义 response：抛出异常的类 常用补充： @Api：用在类上，说明该类的作用如： 123@Api(value= &quot;代理商相关api&quot;)public class ProxyController&#123;&#125; @ApiModel：描述一个Model的信息（一般用于post创建时，使用@RequestBody，请求参数无法使用@ApiImplicitParam注解进行描述） @ApiModelProperty：描述单个model的属性 @PathVariable： 从url模板取值,注意{}；若方法参数名称和绑定的uri template中变量名不一致，需要在@PathVariable(“name”)指定uri template中的名称。如： 1234567@RequestMapping(&quot;/user/&#123;id&#125;&quot;) public void userInfo(@PathVariable int id) &#123; &#125;@RequestMapping(&quot;/user/&#123;id&#125;&quot;) public void userInfo(@PathVariable(name=&quot;id&quot;) int roleId) &#123; &#125; @RequestHeader: 请求header部分的值绑定到方法的参数上 @CookieValue：Request header中关于cookie的值绑定到方法的参数上访问api接口文档输入http://172.16.2.163:8080/swagger-ui.html 访问路径为swagger-ui.html.上一步骤中的查询用户是否为代理的示例效果如下： 安全性api接口文档在内部联调时使用不会有什么问题，正式上线时涉及到安全问题，肯定不可随意访问，后台接口不可暴露。可采用如下安全方案：1.将启用Swagger2的注解注释掉。进入页面时，服务器不会将任何接口返回给浏览器，浏览器拿到的是无任何接口的空页面。效果如下：2.多数情况在上线后仍想访问后台API，则使用拦截器，过滤tokenKey。访问Url如http://172.16.2.163:8080/swagger-ui.html?sdfhiohsdabfnjkawe78oih4342598as1234567891011121314// 请求Swagger2使用key单独过滤if(httpServletRequest.getServletPath().toLowerCase().contains(&quot;swagger&quot;) || httpServletRequest.getServletPath().toLowerCase().contains(&quot;api-docs&quot;))&#123; if(httpServletRequest.getServletPath().toLowerCase().contains(&quot;/swagger-ui.html&quot;)) &#123; if(!httpServletRequest.getQueryString().toLowerCase().contains(&quot;sdfhiohsdabfnjkawe78oih4342598as&quot;)) &#123; httpServletResponse.setStatus(401); return; &#125; &#125; chain.doFilter(httpServletRequest, httpServletResponse); return;&#125;]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-boot打包]]></title>
    <url>%2F2017%2F07%2F02%2Fjar_war%2F</url>
    <content type="text"><![CDATA[Spring-boot相比SpringMVC，基本干掉了繁琐的配置文件，Spring-boot自动完成默认配置。若有自定义配置，在application.properties配置文件覆盖即可。Spring-boot内置tomcat，部署时打成jar包，放到线上启动即可，但独立服务，包文件较大。若多个Spring-boot想使用同一个tomcat或者运维要求Spring-boot项目同其他web项目放到同一容器里，则要考虑打成war包。使用Maven进行项目管理及构建，打包类型配置在依赖文件pom.xml指明。 打成jar包1.声明打包类型为jar1&lt;packaging&gt;jar&lt;/packaging&gt; 2.使用命令 mvn clean package打包部署后，执行1nohup java -jar PokerAgentServer.jar &gt;/dev/null 2&gt;&amp;1 &amp; nohup 表示后台运行，结尾&amp;保证nohup正常运行。&gt;/dev/null 2&gt;&amp;1表示不生成nohup.out文件。声明运行依赖其他类的路径，例如类库及配置文件，则使用-classpath或简写-cp命令，使用此参数则不能使用-jar,-jar会忽略-cp指定的路径1nohup java -cp ../dist/*:../lib/*:../resource org.springframework.boot.loader.JarLauncher &gt;/dev/null 2&gt;&amp;1 &amp; 3.若进行远程调试，使用如下命令：1nohup java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8091 -jar PokerAgentServer.jar &amp; 或1nohup java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8091 -cp ../dist/*:../lib/*:../resource org.springframework.boot.loader.JarLauncher &gt;/dev/null 2&gt;&amp;1 &amp; Host为远程主机地址。开启8091端口。 4.Spring-boot打包会将配置一并达到jar包中，此时需要将resource中的文件删除，再执行mvn clean package打包。启动时，-cp声明依赖的配置文件。1nohup java -cp ../dist/*:../lib/*:../resource org.springframework.boot.loader.JarLauncher &gt;/dev/null 2&gt;&amp;1 &amp;` -jar与-cp有冲突。如果使用-jar选项，java.exe会忽略-cp。这里入口类是org.springframework.boot.loader.JarLauncher，将jar包解压，打开META-INF/MANIFEST.MF文件，如下： 5.输入命令启动，实际加入性能调优参数后，通过sh文件或者python脚本启动。 打成war包1.修改pom文件 打包形式改为war 1&lt;packaging&gt;war&lt;/packaging&gt; 移除嵌入式tomcat 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 添加servlet-api依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;9.0.1&lt;/version&gt;&lt;/dependency&gt; 或 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2.修改启动类，继承SpringBootServletInitializer12345678910111213141516171819202122232425262728@SpringBootApplicationpublic class MainApplication extends SpringBootServletInitializer &#123; private static final Logger logger = LoggerFactory.getLogger(MainApplication.class); @Autowired private Environment env; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class, args); &#125; // 配置filter实现前端的跨域访问 @Bean public FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new CrossOriginFilter()); registration.addUrlPatterns(&quot;/*&quot;); return registration; &#125; @Bean public FilterRegistrationBean filterTokenKeyBean() &#123; logger.info(&quot;path filter is:-&gt;&#123;&#125;&quot;, env.getProperty(&quot;filter.token&quot;)); FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new TokenKeyFilter(Boolean.parseBoolean(env.getProperty(&quot;filter.token&quot;)))); registration.addUrlPatterns(&quot;/*&quot;); return registration; &#125;&#125; 3.使用命令 mvn clean package 打包后，war包放到tomcat的webapps目录下，启动tomcat，即可自动解压部署。浏览器输入路径即可访问：1http://localhost:[端口号]/[打包项目名]/]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-boot 定时任务]]></title>
    <url>%2F2017%2F06%2F25%2Fschedule%2F</url>
    <content type="text"><![CDATA[定时任务在开发中很常见，最近在清理数据库废弃数据时用到定时任务。Spring-boot定时任务如下： 修改入口程序12345678910111213141516171819202122232425262728@SpringBootApplication@EnableSchedulingpublic class MainApplication &#123; private static Logger logger = LoggerFactory.getLogger(MainApplication.class); public static void main(String[] args) &#123; PokerAgentServerConfig.getInstance().requestConfig(); SpringApplication.run(MainApplication.class, args); PokerAgentServerConfig.getInstance().initLogback(); &#125; // 配置filter实现前端的跨域访问 @Bean public FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new CrossOriginFilter()); registration.addUrlPatterns(&quot;/*&quot;); return registration; &#125; @Bean public FilterRegistrationBean filterTokenKeyBean() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new TokenKeyFilter()); registration.addUrlPatterns(&quot;/*&quot;); return registration; &#125;&#125; 不必紧张，Logger为日志相关。两个Bean分别是实现跨域访问和token过滤的。启动定时任务只需这一句：1@EnableScheduling 新建定时任务类1234567891011121314151617@Componentpublic class MyTimer &#123; private static TempTokenDao agentInfoDao = DbManager.create(TempTokenDao.class); @Bean public TaskScheduler taskScheduler() &#123; return new ConcurrentTaskScheduler(); //single threaded by default &#125; /** * 每天凌晨四点清理一次临时表 */ @Scheduled(cron = &quot;0 0 4 * * ?&quot;) public void clearTempToken()&#123; agentInfoDao.deleteAll(); &#125;&#125; 注意： 需要在定时任务的类上加上注释：@Component，在具体的定时任务方法上加上注释@Scheduled即可启动该定时任务。@Scheduled(cron=” * ?”)：按cron规则执行。 扩展以上采用定时到某个时刻。@Scheduled其他应用如下： @Scheduled(fixedRate=3000)：上一次开始执行时间点后3秒再次执行； @Scheduled(fixedDelay=3000)：上一次执行完毕时间点后3秒再次执行； @Scheduled(initialDelay=1000, fixedDelay=3000)：第一次延迟1秒执行，然后在上一次执行完毕时间点后3秒再次执行； 举例：12345//每3秒执行一次@Scheduled(fixedRate = 3000)public void timerRate() &#123; //TODO you want&#125;]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[客户端内嵌WebView与浏览器访问页面的安全机制]]></title>
    <url>%2F2017%2F06%2F24%2Fencryption_trans%2F</url>
    <content type="text"><![CDATA[近期新增代理商系统，游戏内加入webview以及从浏览器登录系统两种方式。作为服务端开发，与主管讨论之后，不同已有基于netty开发的多个服务器，服务端新增基于Spring-boot开发的服务器提供微服务。本文介绍安全机制设计与实现。 客户端内嵌WebView与服务器通信的加密方案安全验证采用token做密钥，摘要算法保证内容正确。摘要算法采用最常见的MD5即可。加密过程是服务端生成token，并把这个token发给客户端，客户端（这里包括WebView内页面）每次请求都附带stime以及token， 对这个字符串做计算形成摘要(sign)。客户端调用WebView之前，通过protobuffer协议获取token。123456789101112131415161718//请求访问代理页面的tokenmessage CGGetAgtTokenREQ&#123;&#125;message GCGetAgtTokenRES&#123; required int32 result = 1; required string token = 2;&#125;&lt;Protocol P_CG_GET_AGT_TOKEN_REQ = &quot;请求访问代理页面的token&quot; PROTOCOL_CLASS=&quot;com.kodgames.message.proto.game.GameProtoBuf.CGGetAgtTokenREQ&quot; /&gt;&lt;Protocol P_GC_GET_AGT_TOKEN_RES = &quot;响应token&quot; PROTOCOL_CLASS=&quot;com.kodgames.message.proto.game.GameProtoBuf.GCGetAgtTokenRES&quot; &gt;&lt;String name=&quot;GC_GET_AGT_TOKEN_SUCCESS&quot; isSuccess=&quot;true&quot;&gt;请求成功&lt;/String&gt;&lt;String name=&quot;GC_GET_AGT_TOKEN_FAILED&quot;&gt;请求失败&lt;/String&gt;&lt;/Protocol&gt; 此时客户端得到的token格式是:1&quot;GAME-&quot;+随机字符串 随机字符串生成规则采用:1UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;).substring(0,16).toUpperCase(); 客户端第一次拉起WebView，发送格式如下。页面直接将请求参数转发到服务端，服务端拿到完整url，在拦截器中用同样的算法做身份验证：1234567http://172.16.2.172:8091/agent/is_agent?id=5006872&amp;stime=1497680416778&amp;sign=35454B055CC325EA1AF2126E27707052其中token = &quot;GAME-XXXXXXXXX&quot;path = &quot;/agent/is_agent&quot;queryString = &quot;id=5006872&amp;stime=1497680416778&quot;sign = md5(queryString + &quot;&amp;token=&quot; + token) queryString是未加密之前的请求字符串，stime是客户端当前时间戳，服务端设置请求有效时间为一分钟，防止重放攻击。由于token只在第一次由服务端下发给客户端，后续无传输，所以在不泄露token的前提下，可有效保证客户端提交数据合法。 token发放机制，采用双token隔离安全性：123456789客户端初次请求服务端获取token，此时token=&quot;GAME-&quot;+随机字符串。客户端拉起webview访问页面，页面第一次向服务端提交请求，控制器判断token的类型，如果token类型是&quot;GAME-&quot;+随机字符串，则控制器重新发放页面内专用的token。此时token=&quot;AGENT-&quot;+随机字符串。webtoken是通过cookie的机制发送：Cookie cookie = new Cookie(&quot;token&quot;,token);httpServletResponse.addCookie(cookie);后续页面内请求均采用此token。退出页面时，把cookie置空，以免token泄露。 每次客户端访问时，会重新向服务端请求token，服务端更新token后发送给客户端。 浏览器网页登录与服务器通信的加密方案浏览器访问的用户认证不采用传统的sessionId，沿袭内嵌WebView与服务器通信的token认证，通过访问路径区分三种安全机制： 用户登录及修改密码采用临时token策略，用户进入页面即获取临时token及uuid，登录请求时携带uuid。服务端验证通过后，将临时token写入到用户正式表中，临时token表删除token。出现到一个问题，就是只有认证成功的用户，临时token才会被删除，其他情况不会被删除，导致临时token表即会越来越大，采用定时任务删除临时表token，即临时token表每天凌晨四点清理一次。涉及到密码相关的传输，密码本身要先加密一次。 用户登录后的安全保障同内嵌WebView与服务器通信的安全机制相同。 发送验证码、初次进入页面、用户确认等无安全威胁的请求，不走安全验证，服务端无需过滤。 举例说明，初次访问页面及登录请求格式如下：123http://172.16.2.163:8091/no_filter/first_comehttp://172.16.2.163:8091/agent/community_login?id=10003&amp;name=10001&amp;pwd=20CC88D2E204FFA768509D33FA882492&amp;type=1&amp;uuid=2f52ef92b73b43659045567ba29881c4&amp;stime=1498728038692&amp;sign=ECD622B701C2B90E33319E7E08A422A9]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端午出游]]></title>
    <url>%2F2017%2F05%2F29%2Fdragon_Boat_Festival%2F</url>
    <content type="text"><![CDATA[明十三陵:樱桃园-水库-蟒山-天池五月底的北京，已经进入炎热的状态，但今儿个天公作美，最高温也就27度，小风不断，十分舒爽。正值樱桃成熟季，于是昨天临时决定摘樱桃。这两张照片看起来跟偷樱桃似的。吃樱桃还是去现场摘的好，个大还甜，最后买了24斤带走，够吃一周的了。快艇师傅真是可以，开的飞快，翻了可咋整。蟒山的天池，是挺大的，空气也不错，就是得爬到山顶，山路只有一条，比较陡。]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见正则合法性校验]]></title>
    <url>%2F2017%2F05%2F24%2Fphone_id%2F</url>
    <content type="text"><![CDATA[正则表达式用于各个情形的数据校验，例如对请求参数的校验，客户端给服务器发送数据前，需初步对数据进行合法性校验；由于客户端数据不可信，服务器要对数据进行严格的合法性校验。本文记录的是常用的身份证及手机号等合法性正则校验。以Java编程为例。 手机号合法性校验这里合法性校验对象为中国大陆及港澳手机号。12345678910111213141516171819202122232425262728/** * 手机号合法性判断（大陆及港澳） */ public static boolean isPhoneLegal(String str) throws PatternSyntaxException &#123; return isMainLandPhoneLegal(str) || isHKPhoneLegal(str); &#125; /** * 大陆手机号码11位数，匹配格式：简单匹配 */ public static boolean isChinaPhoneLegal(String str) throws PatternSyntaxException &#123; String regExp = &quot;^1[3456789]\\d&#123;9&#125;$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); &#125; /** * 香港手机号码8位数，5|6|8|9开头+7位任意数 * 澳门手机号以6开头，可归到香港手机号判断中 * */ public static boolean isHKPhoneLegal(String str) throws PatternSyntaxException &#123; String regExp = &quot;^(5|6|8|9)\\d&#123;7&#125;$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); &#125; 以上手机号校验太严格，一般情况，不建议使用，大陆手机号可用以下正则简单校验即可:1String regExp = &quot;^1[34578]\\d&#123;9&#125;$&quot;; 身份证合法性校验以下是完整的测试函数，包括15位和18位身份证号合法性校验以及15位到18位身份证号的转换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;/** * 身份证合法性校验及15位身份证转为18位 * &lt;p&gt; * --15位身份证号码：第7、8位为出生年份(两位数)，第9、10位为出生月份，第11、12位代表出生日期，第15位代表性别，奇数为男，偶数为女。 * --18位身份证号码：第7、8、9、10位为出生年份(四位数)，第11、第12位为出生月份，第13、14位代表出生日期，第17位代表性别，奇数为男，偶数为女，最后一位为校验位。 */public class IdcardValidator &#123; /** * 省、直辖市代码表： * 11 : 北京 12 : 天津 13 : 河北 14 : 山西 15 : 内蒙古 * 21 : 辽宁 22 : 吉林 23 : 黑龙江 31 : 上海 32 : 江苏 * 33 : 浙江 34 : 安徽 35 : 福建 36 : 江西 37 : 山东 * 41 : 河南 42 : 湖北 43 : 湖南 44 : 广东 45 : 广西 46 : 海南 * 50 : 重庆 51 : 四川 52 : 贵州 53 : 云南 54 : 西藏 * 61 : 陕西 62 : 甘肃 63 : 青海 64 : 宁夏 65 : 新疆 * 71 : 台湾 81 : 香港 82 : 澳门 91 : 国外 */ private static String cityCode[] = &#123;&quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;31&quot;, &quot;32&quot;, &quot;33&quot;, &quot;34&quot;, &quot;35&quot;, &quot;36&quot;, &quot;37&quot;, &quot;41&quot;, &quot;42&quot;, &quot;43&quot;, &quot;44&quot;, &quot;45&quot;, &quot;46&quot;, &quot;50&quot;, &quot;51&quot;, &quot;52&quot;, &quot;53&quot;, &quot;54&quot;, &quot;61&quot;, &quot;62&quot;, &quot;63&quot;, &quot;64&quot;, &quot;65&quot;, &quot;71&quot;, &quot;81&quot;, &quot;82&quot;, &quot;91&quot;&#125;; /** * 每位加权因子 */ private static int power[] = &#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;; /** * 验证所有身份证的合法性 * * @param idcard 身份证 * @return 合法返回true，否则返回false */ public static boolean isValidatedAllIdcard(String idcard) &#123; if (idcard == null) &#123; return false; &#125; else if (idcard.length() == 15) &#123; return validate15IDCard(idcard); &#125; else if (idcard.length() == 18) &#123; return validate18Idcard(idcard); &#125; else &#123; return false; &#125; &#125; /** * 判断18位身份证的合法性 * 根据〖中华人民共和国国家标准GB11643-1999〗中有关公民身份号码的规定，公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。 * 排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。 * 顺序码: 表示在同一地址码所标识的区域范围内，对同年、同月、同 日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配 给女性。 * &lt;p&gt; * (1).前1、2位数字表示：所在省份的代码； * (2).第3、4位数字表示：所在城市的代码； * (3).第5、6位数字表示：所在区县的代码； * (4).第7~14位数字表示：出生年、月、日； * (5).第15、16位数字表示：所在地的派出所的代码； * (6).第17位数字表示性别：奇数表示男性，偶数表示女性； * (7).第18位数字是校检码：也有的说是个人信息码，一般是随计算机的随机产生，用来检验身份证的正确性。校检码可以是0~9的数字，有时也用x表示。 * &lt;p&gt; * 第十八位数字(校验码)的计算方法为： * (1).将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 * (2).将这17位数字和系数相乘的结果相加。 * (3).用加出来和除以11，看余数是多少 * (4).余数只可能有0 1 2 3 4 5 6 7 8 9 10这11个数字。其分别对应的最后一位身份证的号码为1 0 X 9 8 7 6 5 4 3 2 * (5).通过上面得知如果余数是2，就会在身份证的第18位数字上出现罗马数字的Ⅹ。如果余数是10，身份证的最后一位号码就是2。 * * @param idcard 18位身份证号 * @return 是否合法 */ public static boolean validate18Idcard(String idcard) &#123; if (idcard == null) &#123; return false; &#125; // 非18位为假 if (idcard.length() != 18) &#123; return false; &#125; // 获取前17位 String idcard17 = idcard.substring(0, 17); // 前17位全部为数字 if (!isDigital(idcard17)) &#123; return false; &#125; String provinceid = idcard.substring(0, 2); // 校验省份 if (!checkProvinceid(provinceid)) &#123; return false; &#125; // 校验出生日期 String birthday = idcard.substring(6, 14); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMdd&quot;); try &#123; Date birthDate = sdf.parse(birthday); String tmpDate = sdf.format(birthDate); if (!tmpDate.equals(birthday)) &#123;// 出生年月日不正确 return false; &#125; &#125; catch (ParseException e1) &#123; return false; &#125; // 获取第18位 String idcard18Code = idcard.substring(17, 18); char c[] = idcard17.toCharArray(); int bit[] = converCharToInt(c); int sum17 = 0; sum17 = getPowerSum(bit); // 将和值与11取模得到余数进行校验码判断 String checkCode = getCheckCodeBySum(sum17); if (null == checkCode) &#123; return false; &#125; // 将身份证的第18位与算出来的校码进行匹配，不相等就为假 if (!idcard18Code.equalsIgnoreCase(checkCode)) &#123; return false; &#125; return true; &#125; /** * 校验15位身份证 * 只校验省份和出生年月日 * * @param idcard * @return */ public static boolean validate15IDCard(String idcard) &#123; if (idcard == null) &#123; return false; &#125; // 非15位为假 if (idcard.length() != 15) &#123; return false; &#125; // 15全部为数字 if (!isDigital(idcard)) &#123; return false; &#125; String provinceid = idcard.substring(0, 2); // 校验省份 if (!checkProvinceid(provinceid)) &#123; return false; &#125; String birthday = idcard.substring(6, 12); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyMMdd&quot;); try &#123; Date birthDate = sdf.parse(birthday); String tmpDate = sdf.format(birthDate); if (!tmpDate.equals(birthday)) &#123;// 身份证日期错误 return false; &#125; &#125; catch (ParseException e1) &#123; return false; &#125; return true; &#125; /** * 将15位的身份证转成18位身份证 * * @param idcard * @return */ public static String convertIdcarBy15bit(String idcard) &#123; if (idcard == null) &#123; return null; &#125; // 非15位身份证 if (idcard.length() != 15) &#123; return null; &#125; // 15全部为数字 if (!isDigital(idcard)) &#123; return null; &#125; String provinceid = idcard.substring(0, 2); // 校验省份 if (!checkProvinceid(provinceid)) &#123; return null; &#125; String birthday = idcard.substring(6, 12); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyMMdd&quot;); Date birthdate = null; try &#123; birthdate = sdf.parse(birthday); String tmpDate = sdf.format(birthdate); if (!tmpDate.equals(birthday)) &#123;// 身份证日期错误 return null; &#125; &#125; catch (ParseException e1) &#123; return null; &#125; Calendar cday = Calendar.getInstance(); cday.setTime(birthdate); String year = String.valueOf(cday.get(Calendar.YEAR)); String idcard17 = idcard.substring(0, 6) + year + idcard.substring(8); char c[] = idcard17.toCharArray(); String checkCode = &quot;&quot;; // 将字符数组转为整型数组 int bit[] = converCharToInt(c); int sum17 = 0; sum17 = getPowerSum(bit); // 获取和值与11取模得到余数进行校验码 checkCode = getCheckCodeBySum(sum17); // 获取不到校验位 if (null == checkCode) &#123; return null; &#125; // 将前17位与第18位校验码拼接 idcard17 += checkCode; return idcard17; &#125; /** * 校验省份 * * @param provinceid * @return 合法返回TRUE，否则返回FALSE */ private static boolean checkProvinceid(String provinceid) &#123; for (String id : cityCode) &#123; if (id.equals(provinceid)) &#123; return true; &#125; &#125; return false; &#125; /** * 数字验证 * * @param str * @return */ private static boolean isDigital(String str) &#123; return str.matches(&quot;^[0-9]*$&quot;); &#125; /** * 将身份证的每位和对应位的加权因子相乘之后，再得到和值 * * @param bit * @return */ private static int getPowerSum(int[] bit) &#123; int sum = 0; if (power.length != bit.length) &#123; return sum; &#125; for (int i = 0; i &lt; bit.length; i++) &#123; for (int j = 0; j &lt; power.length; j++) &#123; if (i == j) &#123; sum = sum + bit[i] * power[j]; &#125; &#125; &#125; return sum; &#125; /** * 将和值与11取模得到余数进行校验码判断 * * @param sum17 * @return 校验位 */ private static String getCheckCodeBySum(int sum17) &#123; String checkCode = null; switch (sum17 % 11) &#123; case 10: checkCode = &quot;2&quot;; break; case 9: checkCode = &quot;3&quot;; break; case 8: checkCode = &quot;4&quot;; break; case 7: checkCode = &quot;5&quot;; break; case 6: checkCode = &quot;6&quot;; break; case 5: checkCode = &quot;7&quot;; break; case 4: checkCode = &quot;8&quot;; break; case 3: checkCode = &quot;9&quot;; break; case 2: checkCode = &quot;x&quot;; break; case 1: checkCode = &quot;0&quot;; break; case 0: checkCode = &quot;1&quot;; break; &#125; return checkCode; &#125; /** * 将字符数组转为整型数组 * * @param c * @return * @throws NumberFormatException */ private static int[] converCharToInt(char[] c) throws NumberFormatException &#123; int[] a = new int[c.length]; int k = 0; for (char temp : c) &#123; a[k++] = Integer.parseInt(String.valueOf(temp)); &#125; return a; &#125; public static void main(String[] args) throws Exception &#123; String idcard15 = &quot;130321860311519&quot;; String idcard18 = &quot;210102198617083732&quot;;// // 15位身份证 System.out.println(isValidatedAllIdcard(idcard15)); // 18位身份证 System.out.println(isValidatedAllIdcard(idcard18)); // 15位身份证转18位身份证 System.out.println(convertIdcarBy15bit(idcard15)); &#125;&#125; 银行卡号合法性校验123456789101112131415161718192021222324252627282930313233343536373839/** * 校验银行卡卡号 * @param cardId * @return */public static boolean checkBankCard(String cardId) &#123; if(cardId.length() != 16 &amp;&amp; cardId.length() != 19)&#123; return false; &#125; char bit = getBankCardCheckCode(cardId.substring(0, cardId.length() - 1)); if(bit == &apos;N&apos;)&#123; return false; &#125; return cardId.charAt(cardId.length() - 1) == bit;&#125;/** * 从不含校验位的银行卡卡号采用 Luhm 校验算法获得校验位 * @param nonCheckCodeCardId * @return */public static char getBankCardCheckCode(String nonCheckCodeCardId)&#123; if(nonCheckCodeCardId == null || nonCheckCodeCardId.trim().length() == 0 || !nonCheckCodeCardId.matches(&quot;\\d+&quot;)) &#123; //如果传的不是数据返回N return &apos;N&apos;; &#125; char[] chs = nonCheckCodeCardId.trim().toCharArray(); int luhmSum = 0; for(int i = chs.length - 1, j = 0; i &gt;= 0; i--, j++) &#123; int k = chs[i] - &apos;0&apos;; if(j % 2 == 0) &#123; k *= 2; k = k / 10 + k % 10; &#125; luhmSum += k; &#125; return (luhmSum % 10 == 0) ? &apos;0&apos; : (char)((10 - luhmSum % 10) + &apos;0&apos;);&#125; 密码合法性校验（6-10位字母数字组合为例）123456public static boolean isNewPwdIllegal(String str) throws PatternSyntaxException &#123; String regExp = &quot;^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,10&#125;$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches();&#125; 时间格式yyyy-MM-dd hh:mm:ss123456public static boolean isLegalTime(String str)&#123; String regExp = &quot;^(((([0-9]&#123;3&#125;[1-9]|[0-9]&#123;2&#125;[1-9][0-9]|[0-9][1-9][0-9]&#123;2&#125;|[1-9][0-9]&#123;3&#125;)-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]&#123;2&#125;)(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29)) (20|21|22|23|[0-1][0-9]):[0-5][0-9]:[0-5][0-9])$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); &#125; 邮箱格式123456public static boolean isMailLegal(String str)&#123; String regExp = &quot;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); &#125; Ipv4地址123456public static boolean isIpv4(String str)&#123; String regExp = &quot;([1-9]|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]))&#123;3&#125;&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); &#125; Boolean类型的字符串形式123456public static boolean isBoolean(String str)&#123; String regExp = &quot;^(true)|(false)$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str.toLowerCase()); return m.matches(); &#125; unix时间戳，毫秒级，到2030年123456public static boolean isLegalTimestamp(String str) &#123; String regExp = &quot;^1[5-9]\\d&#123;11&#125;$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches();&#125; 其他123合法身份证号简单检测：^\d&#123;14&#125;[\dxX]$|^\d&#123;17&#125;[\dxX]$qq号：^[1-9][0-9]&#123;4,10&#125;$微信号：^[a-zA-Z][-_a-zA-Z0-9]&#123;5,19&#125;$ 微信号规则参考：http://kf.qq.com/touch/faq/120813euEJVf141212Vfi6fA.html]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Limax ZDB简单介绍及死锁分析]]></title>
    <url>%2F2017%2F05%2F22%2Flimax_zdb%2F</url>
    <content type="text"><![CDATA[背景limax是比较小众的应用服务器框架，zdb是limax采用的数据存储方式。zdb采用k-v存储，没有事务的概念，自带锁（加锁和解锁同操作封装在一起，对外隐藏），编程较为简单。项目前期使用zdb进行数据存储，随着项目规模的扩大，暴露出一些问题。每个服务器都有一个zdb.xml文件，基于该文件，ant构建生成的table和xbean也只有当前服务器可以读取。为保证数据一致性，zdb使用方式若未严格注意，导致数据分散在不同职能的服务器上，当某个功能需要的数据需要从不同的服务器上读取时，这就很尴尬了，数据读取繁琐，服务器之间通信协议的繁琐导致编程的繁琐。现在正在逐步废弃zdb，采用主流的mysql+redis存储。 ZDBzdb定义表时，主键无法定义键名，只需定义主键类型。以简单的手机绑定送钻功能为例,zdb设计如下，mobile_id_table为表名，string为主键类型，当前表主键为账户ID，value为记录类，MobileIdBean定义记录包括的字段。 12345678&lt;table name=&quot;mobile_id_table&quot; key=&quot;string&quot; value=&quot;MobileIdBean&quot;/&gt;&lt;xbean name=&quot;MobileIdBean&quot;&gt;&lt;variable name=&quot;accountId&quot; type=&quot;int&quot;/&gt;&lt;!-- 账号ID --&gt; &lt;variable name=&quot;bindTime&quot; type=&quot;long&quot;/&gt;&lt;!-- 绑定时间 --&gt; &lt;variable name=&quot;status&quot; type=&quot;string&quot;/&gt;&lt;!-- 验证状态 --&gt; &lt;variable name=&quot;code&quot; type=&quot;string&quot;/&gt;&lt;!-- 验证码 --&gt; &lt;variable name=&quot;codeTime&quot; type=&quot;long&quot;/&gt;&lt;!-- 验证码发放时间 --&gt;&lt;/xbean&gt; 需求中除了通过手机号查绑定时间和账户ID，还有通过账号ID查绑定时间和手机号。由于zdb的局限性，导致第二张表的产生。zdb查特定数据只能通过主键，所以这里采取双向表的方式，但是有数据冗余的问题，都存储了绑定时间。但是查数据快，无论何种方式查，都仅需查一张表。 123456&lt;table name=&quot;id_mobile_table&quot; key=&quot;int&quot; value=&quot;IdMobileBean&quot;/&gt;&lt;xbean name=&quot;IdMobileBean&quot;&gt;&lt;variable name=&quot;accountMobile&quot; type=&quot;string&quot;/&gt;&lt;!-- 账号手机号 --&gt;&lt;variable name=&quot;bindTime&quot; type=&quot;long&quot;/&gt;&lt;!-- 绑定时间 --&gt;&lt;variable name=&quot;bindAward&quot; type=&quot;int&quot;/&gt;&lt;!-- 绑定所得奖励，历史记录 --&gt;&lt;/xbean&gt; 为解决上述数据冗余的问题，可采用如下方式： 1234&lt;table name=&quot;id_mobile_table&quot; key=&quot;int&quot; value=&quot;IdMobileBean&quot;/&gt;&lt;xbean name=&quot;IdMobileBean&quot;&gt; &lt;variable name=&quot;accountMobile&quot; type=&quot;string&quot;/&gt;&lt;!-- 账号手机号 --&gt;&lt;/xbean&gt; 通过手机查，直接查第一张表。通过账号ID查，查第二张表，拿到手机号后再查第一张表。通过账号ID查数据就变得比较繁琐，需要读两张表。zdb定义定义完成后，cmd到对应路径下执行ant，即生成相应的table类及xbean类。zdb遍历数据效率比较低。只有walk一种方式: 1table.mobile_id_table.get().walk((key, value) -&gt; &#123;return true;&#125;); 操作是从硬盘中读取数据到内存，效率比较低。而且会导致数据不一致的情况，增删改数据后，可能出现内存数据尚未落地到硬盘，get().walk获取的数据是从硬盘直接获得的，获取到的是未执行增删改前的错误数据。 1table.Channel_version_table.get().getCache().walk((key, value) -&gt; &#123; &#125;); 操作是从内存中读取数据，相对于第一种，效率肯定高。这种操作只会读取内存的数据，不会读取硬盘的数据，会导致数据读取不完全。采取的解决方法是起服时将所需表的数据get().walk到内存中，后续数据都是操作内存，除了提升效率外，不会导致数据不一致或数据不完全的情况。zdb读取数据时，能不使用walk遍历就不适用walk遍历数据，可采用配置文件或者哈希表存储主键（适用于记录较少的情况），然后逐一select。select操作是先从内存中读数据，若内存中无数据，再从硬盘中读取数据。 死锁还未弃用zdb时，由于编程的错误导致死锁，这里介绍一下zdb死锁的情况及注意事项。 1234567MobileIdBean mobileIdBean = table.Mobile_id_table.select(phoneNumber);if (mobileIdBean == null)&#123; mobileIdBean = table.Mobile_id_table.insert(phoneNumber); mobileIdBean.setAccountId(roleId); mobileIdBean.setCodeTime(0);&#125; 并发执行select（线程获取读锁）同一个phoneNumber时，会出现多线程进入到if里，执行最快的线程insert（升级为写锁），成功，后续setAccountId等操作正常进行。而其余线程insert失败，返回null，操作出错。应该将select更改为update,初始就获取写锁，并发的后续线程就只能等待前一线程结束，不会出现多个线程同时进入到if的情况。 1234567MobileIdBean mobileIdBean = table.Mobile_id_table.update(phoneNumber);if (mobileIdBean == null)&#123; mobileIdBean = table.Mobile_id_table.insert(phoneNumber); mobileIdBean.setAccountId(roleId); mobileIdBean.setCodeTime(0);&#125; 涉及到后续数据更改的情况，不要使用select，select获取的读锁，其他操作（insert/delete/update）获取的是写锁。 题外话，关于缓存针对主流的mysql+redis存储。由于直接对mysql读写数据效率低，引入缓存可解决效率问题。引入缓存可能会出现与数据库数据不一致的情况，避免这种情况的发生，读写数据时可采取如下策略保证缓存与数据库数据保持一致。 读数据保持一致先读取缓存，若不存在则从DB中读取，并将结果写入到缓存中；下次数据读取时便可以直接从缓存中获取数据。 写数据保持一致（淘汰策略）数据的修改是直接失效缓存数据，再修改DB内容，避免DB修改成功，但由于网络或者其他问题导致缓存数据没有清理，造成了脏数据。 淘汰策略简单容易编程， 但是性能不好，先写入 mysql的时候有可能耗时过长。 可考虑双写策略：不但写入Redis，还会写入 Mysql。双写策略性在Redis上写入性能很好，此时数据立刻可用，在Mysql上可能会出现大量并发写入阻塞，一般会采用高可靠消息队列加强Mysql的写入。 还有一种版本策略，每次写入Redis，做增量写入，不覆盖原有数据，将数据版本增加，采用消息队列延迟写入 Mysql。版本策略编程较为复杂。 如果数据逻辑上是读多写少，采用淘汰策略足够。]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wins下MySQL配置]]></title>
    <url>%2F2017%2F05%2F16%2Fmysql%2F</url>
    <content type="text"><![CDATA[Windows 64bit下通用，配置步骤如下。配置不受Mysql版本号的影响。本例为Win7配置，版本号为5.7.18。 添加环境变量1.系统变量下新建变量，变量名为：MYSQL_HOME，变量值为G:\mysql\mysql-5.7.18-winx642.编辑系统变量的Path，添加变量值;%MYSQL_HOME%\bin 解压MySQL压缩包将下载的MySQL压缩包解压到自定义目录下，我的解压目录是: G:\mysql\mysql-5.7.18-winx64 bin目录下新建my.ini， 复制下面的配置信息到 my.ini 保存1234567891011[client]port=3306default-character-set=utf8[mysqld]port=3306character_set_server=utf8basedir=%MYSQL_HOME%datadir=%MYSQL_HOME%\datasql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[WinMySQLAdmin]%MYSQL_HOME%\bin\mysqld.exe 生成data文件夹1.从控制台进入到MySQL解压目录下的 bin 目录下（直接在目录下按住shift，点击鼠标右键可看到“在此处打开命令行窗口”）2.输入服务安装命令： mysqld --console mysqld --initialize mysqld install 安装成功后会提示服务安装成功：Service successfully installed。之所以执行这几步，是因为在解压目录中没有data文件夹，需要用这几个命令产生data文件夹。注：移除服务命令为：mysqld remove若执行mysqld install后，系统提示Install/Remove of the Service Denied!，则用管理员身份运行cmd即可 启动MySQL服务方法一：启动服务命令为：net start mysql方法二： 打开管理工具 服务，找到MySQL服务。通过右键选择启动或者直接点击左边的启动来启动服务 修改 root 账号的密码当成功进入开启服务以后，cmd下执行 mysql -u root -p 回车，输入密码，出现： ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: NO) 关闭服务 net stop MySQL 用安全模式打开 mysqld --skip-grant-tables 此时光标会一直闪。注意，不要关闭当前窗口，打开另一个命令行窗口。 和前面一样的操作，在bin目录下打开cmd，登录 mysql -u root -p 密码为空,直接回车即可进入。执行 use mysql; update user set authentication_string=password(&quot;123456&quot;) where user=&quot;root&quot;; flush privileges; 登录刚开始启动失败，是因为mysqld进程还开着呢，kill掉重新登录即可。注：若安装成功，进入mysql，不管执行什么命令都提示：You must reset your password using ALTER USER statement before executing this statement.则执行以下三步：12345step 1: SET PASSWORD = PASSWORD(&apos;your new password&apos;);step 2: ALTER USER &apos;root&apos;@&apos;localhost&apos; PASSWORD EXPIRE NEVER;step 3: flush privileges; 拓展以上步骤为win7 下 mysql5.7.18的安装配置，以下为win10下 mysql8.0.11的配置设置环境变量及my.ini的配置不变然后管理员身份运行cmd进入bin目录下，依次执行如下命令即可进入mysql12345mysqld --initialize-insecuremysqld installnet start mysqlmysqladmin -u root password yourpasswordmysql -u root -p yourpassword 用Navicat或hedisql连接mysql时，提示：Authentication plugin ‘caching_sha2_password’ cannot be loaded可用如下方法解决：进入mysql中，执行如下命令12ALTER USER &apos;yourusername&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;youpassword&apos;;flush privileges;]]></content>
      <tags>
        <tag>技术</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效洗牌算法介绍]]></title>
    <url>%2F2017%2F04%2F14%2Fshuffle_introduce%2F</url>
    <content type="text"><![CDATA[最近写了一个梭哈牌戏Demo，简单介绍用到的洗牌算法。123456789101112131415161718public void shuffle()&#123; // 随机位数索引 int tmpIndex; // 临时存储数组当前值 Card tmpCard; for (int i = 0; i &lt; CardDeck.DECK_SIZE; i++) &#123; tmpIndex = (int)(Math.random() * CardDeck.DECK_SIZE); if (tmpIndex != i) &#123; tmpCard = cards[tmpIndex]; cards[tmpIndex] = cards[i]; cards[i] = tmpCard; &#125; &#125; return;&#125; 思想：从数组第一位开始，随机random一个数字，第一位和随机出的那位交换；然后依次遍历这个过程到最后一张牌。时间复杂度O(n)，空间复杂度O(1)。优点：与抽牌算法（随机抽牌放到新数组，直到抽完为止）相比，当前洗牌算法随机性更强，已随机的位数仍会与后面随机的数位交换；无需开辟新数组，空间复杂度降低。另外，Demo与传统梭哈相比，加入五张鬼牌，难度升级。牌型判断及简单机器博弈算法还是有点难度的。感兴趣可看下Demo：Github链接]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏开发历程记录-H5]]></title>
    <url>%2F2017%2F03%2F26%2FH5_record%2F</url>
    <content type="text"><![CDATA[背景H5游戏前端开发有将近一年经验，大部分项目都是单兵作战。主要使用引擎和语言为Egret(TypeScipt)，Construct2(JavaScript)。前端完全独立开发的上线游戏有三款：Survival（活下去），砰砰兔，IO游戏炸弹人。现在转向游戏服务端开发，开发语言目前以Java为主，项目包括App及H5，棋牌类为主。这里是对之前的H5开发项目进行阶段性的总结。 正式项目Survival：开发的第一款H5手游，负责后半段的前后端开发。Egret GUI项目,后端使用php和mysql，文字类游戏,视频链接。 个人服务器demo链接地址 ，demo太简陋，感兴趣直接到qq空间玩一下。砰砰兔：简单的Egret EUI项目，个人服务器demo链接地址。IO游戏炸弹人：以泡泡堂为原型，国内海外两版，周期三个月。使用网易pomelo框架，前端主要是业务逻辑和插件的开发，后端由一个小伙伴负责，主要使用node。 练习项目时钟大战：简单的Egret EUI 项目，链接地址。飞机大战（链接地址）及flappybird（链接地址）: Construct2小项目,美术素材就是从网上随便找的。Construct2中引入Spriter插件进行骨骼动画测试，测试效果链接,相比帧动画，性能和效果流畅度提升，但是对象数量飙升。若项目对象数量少，如对打或者闯关游戏，可选择使用。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>Html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.gitignore & .gitattributes 简介]]></title>
    <url>%2F2017%2F03%2F12%2FgitIgnore%2F</url>
    <content type="text"><![CDATA[.gitignore文件使用git做版本管理时，首先在根目录建README.md和.gitignore文件，.gitignore为忽略不必要提交的文件，特殊文件不加入版本库中，如编辑器缓存，若ide使用idea，.gitignore文件则要添加：123**/.idea**/*.iml**/target **表示所有层级目录 Github标记图标的更改github上传新项目时，发现没有分类图标（图标错误也是这么改），这里将添加过程记录下来。根目录下新建.gitattributes文件，将以下内容复制保存。123*.js linguist-language=Java*.css linguist-language=Java*.html linguist-language=Java 该文件将html、css、js（想关联的文件）文件关联为Java(目标类型)。此时，github将此项目识别为Java项目。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Construct2使用心得]]></title>
    <url>%2F2017%2F03%2F03%2Fconstruct2_conclusion%2F</url>
    <content type="text"><![CDATA[Construct2从接触到使用已有半年时间，优点就是上手容易，开发快，但只适合小型2D-H5游戏且是闭源，很适合懂技术的策划使用，对程序猿来讲，玩玩即可。同大多数H5游戏引擎相同，也是一次开发，导出多平台包。引擎本身只提供基础功能，插件的使用及开发是Construct2核心之一。官方论坛上有各种需要的插件，C2插件大神Rex贡献尤为突出。 前端架构建议 将全局变量统一放到一个事件表中，我习惯命名为Global，统一管理全局变量。 不能过分使用全局变量，根据变量的作用域分类，只跟某个对象有关放到对象的局部变量中；如果变量只在当前layout有效，可以考虑放到对象的局部变量中，或者当前布局所有事件放到一个大组里，变量声明在当前组内。 资源管理上，在Object types下建立子文件夹；对象动画较多或者打算将多个对象合并到一个对象上（也建议这么做）时，对象动画位置建立子文件夹。 对于行为完全相同的对象，要放到同一个family中。 根据功能分类，合理使用Group。 多使用Function，如果当前布局事件过多（如超过200条），将所有函数放到一个事件表中，然后在主事件表中引入。 如果不使用 C2默认的loader布局，将use loader layout选为yes , 将first layout选择个人定义的加载布局，但是如果个人设置的加载布局稍微有些复杂，C2的默认的loader布局依然会显示，此时将发布包的logo替换即可。 若一个物体如boss由多个对象组成，将多个对象放到一个container中；希望某些对象同时创建或者删除，也考虑使用container，很好用。使用container时，选择container的某个对象，此时可直接操作该container的其他对象，选择当前对象的过程也是选择当前整个container。 对象尽量少，若多个对象有不同动画但是功能完全相同，统一成一个对象（类）上，通过不同动画控制显示或者通过同一动画的不同帧来控制。 spriter在construct2中支持良好，很多情况下都可以选择骨骼动画而不是帧动画，尤其是对象数量较少的情况下。 性能优化及使用小结 关闭不需要碰撞对象的碰撞（默认都开启），提高前端性能。 C2若使用全套物理引擎即对象引入physics属性，对于pc端，为保证性能，物理对象不能超过100，移动端不能超过40。物理对象只能与物理对象交互。 若浏览器不支持webgl，运行期间会出现闪退，禁用webgl即可，此时为canvas。 将要声音的格式转为wav,引入的过程，引擎会自动转为ogg和m4a两种格式。 Form control下的对象如Button处于游戏视图最上层。可直接更改css更改样式。 C2可打包成多种类型，如H5,Android,Nw.js等。打包成app，需之后使用phonegap build等工具构建app。 talkingData等接入，需在index.html文件中引入外源文件。 踩过的坑 set size 不能和 set scale连用，相当于同一种操作，都是在原始对象尺寸上做更改，后者会覆盖前者。 设置子弹属性，应先设置速度，再设置角度，因为如果设置角度，速度若为0，不生效。 C2数组push元素，之后clear,不会生效，push的元素依然在。 隐形Button不可用，设置成visible后，touchEnabled也被禁用。 invisible的对象仍可touch，如果想实现打开某个页面后，下面图层的对象不可touch，可采取给不可touch的对象加入控制变量及cooldown属性(冷却时间设为0.1秒)，当页面打开后，控制变量更改，cooldown request，当cooldown finish时，控制变量重置。 C2中类型有限，而且调用calljs将text类型的变量作为参数时，应如下”output(“””&amp;userID&amp;”””)”，注意userID两侧的引号，若无引号”output(“&amp;userID&amp;”)”，会导致获取到的userID不是字符串，而是没有引号的字符串，很奇怪。 callJs不可在on start of layout使用。 涉及到回调处理时，均需封装成C2插件，在插件内执行。如superSDK接口调用。 C2中无法实现console.log(),只能设置Text值进行输出，可使用callJS, js中输出。执行某个操作但是需在回调中处理逻辑，需封装成插件。 C2插件大神rexRainbow说，c2没有什么是一个wait不能解决的，如果有，那就两个。合理使用wait0，填引擎自身的坑。 曾使用及开发的插件behaviors插件 设置对象椭圆运动—cicle 实现通过名字创建特定对象，需behavior插件rex_bnickname与plugin插件rex_nickname一同引入 冷却时间，倒计时使用，需behavior插件rex_cooldown与plugin插件rex_timeline一同引入 rex_moveto，设置对象移动到某个位置，常用做爆炸类特效 rex_pin2imagepoint，官方只能将对象pin到另一个对象imagePoint=0的位置，只有一个pin点，使用此行为可以pin到某个对象的不同imagePoint上 liteTween,缓动动画effects插件 浮雕颜色anaglyphcolor 背景模糊特效basicBlurplugins插件 JSON_for_construct2-master—JSON数据存储与使用 callJS—调用外部js scml是C2的spriter骨骼动画插件 spritefont+，第三方字体插件；C2SpriteFont制作工具,C2字体制作工具，配合C2自带的spritefont使用 rex_gfsm为FSM插件，有限状态机 最近开发的IO游戏炸弹人，前后端通信使用网易的Pomelo。C2的数据类型很少，数据处理这块做的不好，于是将pomelo及superSDK封装为C2插件，游戏客户端与服务器的数据处理及通信等即在这两个插件中完成。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JavaScript</tag>
        <tag>Construct2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window下修改本机dns及本机域名]]></title>
    <url>%2F2017%2F02%2F05%2Fwin_dns%2F</url>
    <content type="text"><![CDATA[修改本机dns服务器本地dns出现问题，如某些域名访问不到（无法解析），可修改本机dns服务器路径：控制面板-&gt;网络和Internet-&gt;网络连接-&gt;本地连接-&gt;右键属性-&gt;网络-&gt;双击Internet协议版本4（TCP/IPV4），显示如下修改为如下8.8.8.8及8.8.4.4是google提供的公用dns服务器,其他大厂也提供了公用dns服务器，随意选个用就行。 修改本机域名解析hosts文件添加域名解析，可实现 自定义域名在本地访问本机，实际没啥用，如添加1127.0.0.1 dev.test.com cmd下查看域名解析（nslookup），可看到域名已指向本机，本机可通过域名访问本地服务。 解决域名污染的问题。未备案的域名指向个人搭建的服务器，不幸的话，会遇到域名污染的情况，无法通过域名获取服务，可修改hosts文件添加本机域名解析，一定程度解决问题 翻墙，下载可靠的hosts文件，替换本机hosts文件，可一定程度翻墙。正经翻墙还是需要有国外服务器，搭建个梯子，正向代理。hosts文件路径：1C:\Windows\System32\drivers\etc\hosts]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下使用Hexo+Github搭建个人博客]]></title>
    <url>%2F2017%2F01%2F01%2Fhexo_gitpages%2F</url>
    <content type="text"><![CDATA[Hexo介绍静态博客生成器，根据给定的主题，负责把写好的 Markdown 文章转换成一堆 HTML + CSS + Javascript 页面。另外，Hexo 还有把生成好的站点上传到 Github Pages 的功能。 背景记录个人学习和生活，作为程序猿，搭建个人博客是个不错的选择。但只是个博客，购买云服务器有些不值当，服务器稍微好些的配置就得上千。之前好友买过国外的服务器，hosts不加域名解析经常访问不到，更悲催的是，.com域名还被污染了，吓得我抱紧自己，决定用免费的gitPages吧。搭建的时候看过一些教程，还是遇到了一些问题（其实直接看hexo官网就ok的）。我在搭建时，使用的是Win10系统，以下搭建步骤是支持所有Wins系统的。OS系统下搭建与Wins不同，以hexo官网为准，可参考本文 搭建步骤 1.首先安装git及node，申请github账号并将ssh key配置完成。 2.cmd下输入powershell，进入cmd超级加强版（这一步可忽略，对搭建博客无影响）。 3.npm的任何操作都无法使用时，卸载node重装，并删除 C:\Users\Administrator\AppData\Roaming\npm C:\Users\Administrator\AppData\Roaming\npm-cache文件夹 4.在安装npm时，可能根据某个教程设置了例如： npm config set prefix &quot;C:\Program Files\nodejs\node_global&quot; npm config set cache &quot;C:\Program Files\nodejs\node_cache&quot; 设置出错可能就导致npm无法使用，此时需恢复到默认。npm config恢复到默认只需删除C:\Users\Administrator.npmrc文件。如果.npmrc不在这个目录下，就全局搜一下啦。当我遇到第3和第4步，我的内心是这样的 5.安装hexo，执行命令 npm install hexo-cli -g 6.安装hexo生成页面部署到github的组件，执行 npm install hexo-deployer-git --save 7.创建放置博客文件的文件夹 hexo init blog 8.进入到新创建的博客项目中 cd blog 9.安装依赖包 npm install 10.生成博客页面 hexo generate 11.本地起服 hexo server 浏览器访问 http://localhost:4000/ 可以预览博客样式 12.github创建仓库：仓库名必须为youname.github.io, 例如我的仓库名为monkeydbean.github.io 13.在本地博客目录下，打开git bash,以我的为例，执行 git init git add remote origin https://github.com/MonkeyDBean/MonkeyDBean.github.io.git 14.配置文件_config.yml更改如下1234deploy: type: git repo: https://github.com/MonkeyDBean/MonkeyDBean.github.io.git branch: master 注：YAML语法，字典是由简单的键: 值的形式组成(冒号后面必须是一个空格),如type:+&amp;nbsp+git 15.部署到github，执行 hexo deploy 若提交不上去，检查语法；没问题的话重新执行 npm install hexo-deployer-git --save hexo deploy 执行到这一步，以上步骤没问题的话，浏览器输入 https://monkeydbean.github.io 可访问个人博客，此时只有HelloWorld单页面。 16.每次部署，可按以下步骤进行： hexo clean hexo generate hexo deploy 17.让博客炫起来，最简单的，得有个主题，搜索输入hexo 知乎，选一个主题开始使用吧，主题的使用方法在相应主题的github上有详细介绍。包括头像、站点图标等基础设置及第三方接入等高级设置。 18.绑定域名：首先得有一个域名，域名服务商有很多，我这里用的万网，阿里云域名服务用的就是万网。注册完成后，搜索心仪域名是否被使用，未被使用即可购买，.cn域名比较便宜，第一年29元，无需购买扩展服务。域名购买完成后，添加cname解析如下：同时，在博客public目录下新建CNAME文件：执行步骤16，浏览器输入monkeyben.cn即可访问个人博客。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Http中GET与POST的区别]]></title>
    <url>%2F2016%2F10%2F29%2Fget_post%2F</url>
    <content type="text"><![CDATA[最近看了几篇介绍GET与POST的文章，讲的很有意思，在这里引用总结一下。 区别Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE，分别对应着资源的查，改，增，删。 GET和POST是HTTP请求的两种基本方法，GET一般用于获取资源信息，而POST一般用于更新资源信息。 GET请求在URL中传送的参数是有长度限制的，最多只能是1024字节，理论上POST木有限制，可传较大量的数据。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 GET在浏览器回退时是无害的，而POST会再次提交请求。 …………灯，灯灯灯灯从表面看，GET与POST的区别那么多，实际上呢？让我们扒下GET和POST的外衣，坦诚相见吧! 定义根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。根据HTTP规范，POST表示可能修改变服务器上的资源的请求。请注意，这几个字“根据HTTP规范”。HTTP是什么?HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。GET和POST又是什么?HTTP协议中的两种发送请求的方法。 比喻在万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到。 本质GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包;POST产生两个TCP数据包。长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么?1.GET与POST都有自己的语义，不能随便混用。2.据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。3.并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egret简略总结]]></title>
    <url>%2F2016%2F09%2F02%2Fegret_conclusion%2F</url>
    <content type="text"><![CDATA[Egret使用已有大半年，相比其他H5引擎，Egret的优势是官方文档齐全，配套工具完善，但性能不是很突出。 曾使用官方提供的配套工具 界面排布及属性预设—Egret Wing 碎图压缩合成大图及MovieClip动画素材处理—TextureMerger 资源管理—ResDepot chrome下调试插件—Egret Inspector 粒子效果制作—EgretFeather 当然，代码编写还是要用WebStorm及Sublime。以及开发中常用到的小小工具：在线图片压缩—TinyPng.com,合图分割—pngSplit，在线Json转换—bejson，二维码生成器cli.im等等。 调试参数说明及MovieClip index.html中，data-entry-class = “Main”,进入游戏访问的第一个Ts文件，入口类；data-orientation=”auto”,旋转方向设置；data-frame-rate = “60”,游戏帧率设置，可更改，建议为60的约数，正式项目基本设置为60，测试时更改。data-show-fps=”false”,默认为false,开启后可看到实时帧率，测试使用；data-show-log = “false”,默认为false,开启后，代码中egret.log()中的内容即显示在屏幕中，测试使用。 开启fps后的参数说明。FPS为帧率；Draw为每帧draw方法调用的平均次数，脏矩阵占舞台的百分比；Cost为每帧舞台所有事件处理及矩阵运算耗时，绘制显示对象耗时（单位为ms）。 MovieClip举例123456789101112131415161718192021222324252627282930class Bomb extends egret.Sprite&#123; private mcf:egret.MovieClipDataFactory; private mc:egret.MovieClip; public constructor() &#123; super(); this.init(); &#125; public init(str1:string,str2:string,number:number):void &#123; var data = RES.getRes(str1); var tex = RES.getRes(str2); this.mcf = new egret.MovieClipDataFactory(data, tex); this.mc = new egret.MovieClip(); this.mc.movieClipData = this.mcf.generateMovieClipData(); this.mc.play(number); //playTimes:number — 播放次数。 参数为整数，可选参数，&gt;=1：设定播放次数，&lt;0：循环播放，默认值 0：不改变播 放次数(MovieClip初始播放次数设置为1)， this.addChild(this.mc); this.mc.addEventListener(egret.Event.COMPLETE, this.removeBomb, this); &#125; //轰炸完毕 private removeBomb(evt:egret.Event):void &#123; if(this.parent!=null) &#123; this.parent.removeChild(this); &#125; &#125;&#125; 性能优化 Audio 如果需求中需要同时播放多个音频，则使用WebAudio。X5浏览器内核WebAudio可支持多音频。Egret3.1.4之后，index.html文件中，egret.runEgret({renderMode:”webgl”,audioType:0}); 默认的渲染模式为Canvas,之前微信平台上的游戏使用的均为Canvas。音频类型中，默认为0，IOS7以上表示WebAudio；1表示QQ Audio，项目若在腾讯平台上线如QQ空间中的玩吧，则使用QQ Audio，腾讯解析音频有自己的一套方案；2表示强制使用WebAudio;3表示使用浏览器自带的Audio，不推荐。 当多个音频轮询播放播放的时候，如ababa，如果打开网络侦听，有可能发现播放一次向服务器请求一次，原因是不同浏览器内核对音频实现方式不一样。解决方案是：将轮询播放的多个音频拼成一个音频，通过时间段控制播放。 由于浏览器的安全限制，加载完成可能无法自动播放背景音乐，这种情况将背景音乐设置成点击播放的形式，如加载完成后，弹出按钮，玩家点击选择是否播放背景音乐。主流H5游戏均是采用这种方式。 Text TextField中使用cacheAsBitmap，可以减少重绘次数。原因是TextField是文本，浏览器渲染通过CPU的计算，对图片渲染速度快，对文本渲染速度慢。 TextField减少对于描边（stroke）的使用，用图片代替。 输入文本框尽量出现在软键盘的上面，手机部分浏览器中，如果输入文本框太靠下，弹出的软键盘会遮挡住输入文本框。 Image 单张图（包括SpriteSheet）的大小不要超过1024*1024,浏览器对图片大小限制会对超过的该尺寸大小的图片进行自动压缩处理导致图片模糊发虚。 将碎图合成一张大图，每次进行图片下载时会先进行TCP三次握手协议，这个时间会超过较多小图下载的时间。 使用九宫格时，不要使用非整数宽高；在List控件中不要使用九宫格图片来减少draw的次数。 单静态页面，cacheAsBitMap可以减少重绘次数。如在大图中取出部分碎图组成的单静态页面。 使用SpriteSheet合并的图片尺寸要优于单张图片的总尺寸，尤其是带透明通道的。 NetWork 素材处理。不要一次性下载太多的素材，尽量分布在使用前加载。将碎图和成一张大图，减少下载次数。Png图可以使用压缩工具（如TinyPng）压缩减少体积。 配置文件。尽量将配置文件合并到一个大文件里，减少下载次数。在Http请求中，加载单个文件速度要优于加载多个文件。配置文件去掉格式化，利用在线Json格式化工具（如bejson，sojson）处理Json数据。Json数据可以去掉一些不必要的小数和冗长命名。 下载处理。资源服务器开启GZIP压缩，提高载入速率；登录加主页面素材不要超过2M；加入静默加载，比如在登录界面操作时下载主页面相关素材。 Mask 遮罩如果是DisplayObject，必须加入到显示列表后，方能正常使用。 遮罩如果是Rectangle，修改遮罩数据后，重新将遮罩赋值给对象。 DisplayObject Shape/DisplayObjectContainer，能通过父层计算出来的交互不直接在子容器里加。如EUI中，Group组件中有Image组件，Touch Image的监听直接将Touch监听加在Group上，如果是一个Group中有多张图需要有监听事件，可在Group上加一个监听，根据Group的Touch位置进行响应。 禁用不必要显示对象的触摸交互，默认就是关闭的。但是开发时，自己的写的底层框架可能又给打开了，eui的touchenable是默认打开的，不需要touch事件监听时需手动关闭。触摸屏幕实际上就是触摸canvas,canvas根据位置在显示列表中逐层搜索，实际上也是碰撞检测。 1234567var sp :egret.Sprite = new egret.Sprite();this.addChild(sp);sp.touchChildren = false; //确定子孙对象是否接受触摸事件，默认为truesp.touchEnabled = false; //此对象是否接受触摸事件，默认为true 能用图片的不用Graphics实现。 尽量将静态图或者文字放到一个容器中，并对容器缓存（cacheAsBitMap）。 减少显示对象的旋转及缩放。 尽可能重用对象，建立对象池，而不创建对象并对其执行垃圾回收。创建对象时，将对象创建在循环外部并在循环内反复重用。需要密集的创建对象，要引入对象池，例如做一款打飞机类型的游戏，进入战斗前，飞机，怪物，掉血特效等对象提前初始化，在过程中实时提取，而不是实时创建。 对象复用与释放 Event派发要合理使用Event自带的静态方法，如egret.Event.dispatchEvent(this,”dragonbones”)。 事件删除，用完事件即删除。 Tween循环结束时，删除。 显示列表删除，面板不使用则remove掉。 显示停止计时器，让它们准备好进行垃圾回收。暂停清除计数器clearInterval()、clearTimeout()、Timer.stop()。 TypeScipt 尽量不要在使用方法内创建函数，一个函数内不要嵌套另一个函数的定义 Ts中没有super属性的调用，Js类继承的本质是通过原型链实现的，但是egret提供了egret.superGet 和 egret.superSet 来调用父类属性。 类方法中，将this赋值给另一个临时变量self，var self = this;如果当前类this使用较多，如for循环内使用时，使用self。 其他 LocalToGlobal后的坐标不要有小数；一般情况下坐标计算等也尽量不使用小数。 对象复用比较高时，如打飞机的子弹，使用对象池优化。 尽量减少Alpha混合的使用。 多次调用类属性时，避免直接使用this，如果for循环一直用到this.a，可var _a = this.a，用变量做简单缓存再去计算，效率就会提升，如_length = Array.length。 Event.ENTER_FRAME数量控制。MainLoop包括ENTER_FRAME（每帧主要执行逻辑）-&gt;CLEAR(清空上一帧图像) -&gt;UPDATE TRANSFORM(计算这一帧的显示) -&gt; UPDATE DRAW。 位移如跑酷游戏的计算不要通过帧数来计算，通过时间来计算。 使用60的约数作为帧频数。Egret自带Timer，每秒固定振荡60次。 对于简单的动画，使用序列帧或者db的急速模式。 非动作游戏降低帧率可大幅提高性能。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>TypeScript</tag>
        <tag>Egret</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库范式学习总结]]></title>
    <url>%2F2016%2F08%2F05%2Fdatabase_introduce%2F</url>
    <content type="text"><![CDATA[近期重温数据库范式。 第一范式（1NF）属性不可再分，强调的是原子性。如表：【联系人】（姓名，性别，电话），在实际场景中，联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。要符合 1NF 我们只需把列（电话）拆分，即：【联系人】（姓名，性别，家庭电话，公司电话）。 第二范式（2NF）首先，符合1NF，并且，非主属性完全依赖于码，即没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。强调的是完全依赖而非部分依赖。考虑一个订单明细表：【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName）。 因为我们知道在一个订单中可以订购多种产品，所以单单一个 OrderID 是不足以成为主键的，主键应该是（OrderID，ProductID）。显而易见 Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID。所以 OrderDetail 表不符合 2NF。不符合 2NF 的设计容易产生冗余数据。可以把【OrderDetail】表拆分为【OrderDetail】（OrderID，ProductID，Discount，Quantity）和【Product】（ProductID，UnitPrice，ProductName）来消除原订单表中UnitPrice，ProductName多次重复的情况。 第三范式（3NF）首先，符合 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 强调的是消除传递依赖。考虑一个订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID）。其中 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。通过拆分【Order】为【Order】（OrderID，OrderDate，CustomerID）和【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。 BC范式（BCNF）任何字段都不能传递依赖任一侯选关键字。第三范式为非主键列不能传递依赖，而BC范式为所有键列都不能传递依赖。在第三范式的基础上，进一步消除了主属性的传递依赖。BC范式既检查非主属性，又检查主属性。 第四范式（4CF）把同一表内的多对多关系删除。 第五范式（5CF）从最终结构重新建立原始结构。 正确认识数据冗余主键与外键在多表中的重复出现, 不属于数据冗余，这个概念必须清楚。非键字段的重复出现, 才是数据冗余！而且是一种低级冗余，即重复性的冗余。高级冗余不是字段的重复出现，而是字段的派生出现。例：商品中的“单价、数量、金额”三个字段，“金额”就是由“单价”乘以“数量”派生出来的，它就是冗余，而且是一种高级冗余。冗余的目的是为了提高处理速度。只有低级冗余才会增加数据的不一致性，因为同一数据，可能从不同时间、地点、角色上多次录入。 总结绝大多数实际开发最多用到BC范式。第四和第五范式感兴趣多看看资料，了解即可。范式不是越高越好，过于范式化会对数据库的逻辑可读性和使用效率起到阻碍。数据库连接有性能消耗，实际开发过程中，会有数据冗余，以空间换时间，所以提倡高级冗余(派生性冗余)，反对低级冗余(重复性冗余)。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业]]></title>
    <url>%2F2016%2F06%2F10%2Fgraduate%2F</url>
    <content type="text"><![CDATA[贴几张照片~教学区到体育馆的路上，亮眼的毕业三字-.-来一桶图书馆体育场教学区软院正门对比一下大一青葱： Your browser does not support the audio tag.]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>