<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot+Mybatis配置多数据源]]></title>
    <url>%2F2017%2F10%2F09%2Fmulti_datasource%2F</url>
    <content type="text"><![CDATA[开发企业级应用程序时常遇到要使用多个服务器上数据库的情况，此时需要配置多个数据源。查阅相关资料，遇到不少坑，亲测如下： 项目目录结构 关键文件pom文件配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.kodgames&lt;/groupId&gt; &lt;artifactId&gt;MultiDataSource&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;MultiDataSource&lt;/name&gt; &lt;description&gt;test Spring boot multi Datasource&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;jarName&gt;MultiDataSource&lt;/jarName&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring Boot web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL JDBC驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.zaxxer/HikariCP --&gt; &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt;*.*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; application.properties配置文件12345678910111213server.port=8095# Primary DataSource configurationdatasource.primary.url=jdbc:mysql://123.206.224.79/club4agency?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falsedatasource.primary.username=gymj_writedatasource.primary.password=q9oL2G2ZVidatasource.primary.driver-class-name=com.mysql.jdbc.Driver# Secondary DataSource configurationdatasource.secondary.url=jdbc:mysql://182.254.139.94/mahjongforagency?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falsedatasource.secondary.username=qa_writedatasource.secondary.password=xPpfgs4TzjBxV7datasource.secondary.driver-class-name=com.mysql.jdbc.Driver ApplicationConfiguration配置类1234567891011121314151617181920212223242526272829303132333435363738package com.test.multi.component.config;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.sql.DataSource;/** * Created by Bean on 2017/10/9. */@Configuration@MapperScan(value = &quot;com.test.multi.component.dao.dao1&quot;, sqlSessionFactoryRef = &quot;primarySqlSessionFactory&quot;)public class ApplicationConfiguration &#123; @Bean(name = &quot;primaryDatasource&quot;) @Primary @ConfigurationProperties(prefix = &quot;datasource.primary&quot;) public DataSource primaryDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = &quot;primarySqlSessionFactory&quot;) @Primary public SqlSessionFactory sqlSessionFactory1(@Qualifier(&quot;primaryDatasource&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:ClubDataDaoMapper.xml&quot;)); return bean.getObject(); &#125;&#125; 同样的，ApplicationConfiguration2配置类1234567891011121314151617181920212223242526272829303132333435package com.test.multi.component.config;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.sql.DataSource;/** * Created by Bean on 2017/10/9. */@Configuration@MapperScan(value = &quot;com.test.multi.component.dao.dao2&quot;, sqlSessionFactoryRef = &quot;secondSqlSessionFactory&quot;)public class ApplicationConfiguration2 &#123; @Bean(name = &quot;secondaryDataSource&quot;) @ConfigurationProperties(prefix = &quot;datasource.secondary&quot;) public DataSource secondDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = &quot;secondSqlSessionFactory&quot;) public SqlSessionFactory sqlSessionFactory2(@Qualifier(&quot;secondaryDataSource&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:GmDataDaoMapper.xml&quot;)); return bean.getObject(); &#125;&#125; ApplicationConfiguration与ApplicationConfiguration2配置类，@MapperScan指定扫描域要区分开，两个dao文件ClubDataDao与GmDataDao分别操作不同的数据源。 ApplicationConfiguration与ApplicationConfiguration2配置类，sqlSessionFactoryRef参数声明mybatis sqlsessionfactory来源。 @Primary仅注解到单个数据源，作为默认数据源，用作操作频率最高的数据源上（也常用来区分主从数据库，这个与本文无关）。 其他文件ClubDataDao12345678910package com.test.multi.component.dao.dao1;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface ClubDataDao &#123; List&lt;Integer&gt; queryClubManagerIdByAgencyId(int agencyID);&#125; GmDataDao123456789package com.test.multi.component.dao.dao2;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface GmDataDao &#123; Integer queryGroupIdByAgencyId(int agencyID);&#125;` ClubDataDaoMapper.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.test.multi.component.dao.dao1.ClubDataDao&quot;&gt; &lt;select id=&quot;queryClubManagerIdByAgencyId&quot; resultType=&quot;Integer&quot; parameterType=&quot;Integer&quot;&gt; select DISTINCT club_manager_id from club4agency.agency_club_info where club_agency_id=#&#123;agencyID&#125;; &lt;/select&gt;&lt;/mapper&gt; GmDataDaoMapper.xml1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.test.multi.component.dao.dao2.GmDataDao&quot;&gt; &lt;select id=&quot;queryGroupIdByAgencyId&quot; resultType=&quot;int&quot;&gt; select groupId from account where agencyID = #&#123;agencyID&#125;; &lt;/select&gt;&lt;/mapper&gt; CrossOriginFilter12345678910111213141516171819202122232425262728293031package com.test.multi.component.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by Bean on 2017/10/9. */public class CrossOriginFilter implements Filter &#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest) request; HttpServletResponse httpServletResponse = (HttpServletResponse) response; httpServletResponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); chain.doFilter(httpServletRequest, httpServletResponse); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; Swagger21234567891011121314151617181920212223242526272829303132333435363738394041package com.test.multi.component.doc;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * Created by Bean on 2017/10/9. */@Configuration@EnableSwagger2public class Swagger2 &#123; public static Contact contact = new Contact(&quot;MonkeyBean&quot;, &quot;http://hostip:8095/swagger-ui.html&quot;, &quot;monkeybean_zhang@163.com&quot;); @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.test.multi&quot;)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;) .description(&quot;多数据源测试&quot;) .termsOfServiceUrl(&quot;https://www.google.com/&quot;) .contact(contact) .version(&quot;1.0&quot;) .build(); &#125;&#125; 测试类TestController1234567891011121314151617181920212223242526272829303132333435363738394041package com.test.multi.controller;import com.test.multi.component.dao.dao1.ClubDataDao;import com.test.multi.component.dao.dao2.GmDataDao;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.List;/** * Created by Bean on 2017/10/9. */@RequestMapping(path = &quot;test&quot;)@RestControllerpublic class TestController &#123; @Autowired private ClubDataDao clubDataDao; @Autowired private GmDataDao gmDataDao; /** * 测试多数据源 */ @ApiOperation(value = &quot;testMultiDataSource&quot;) @RequestMapping(path = &quot;multi&quot;, method = RequestMethod.GET) public HashMap&lt;String, Object&gt; testMulti(@RequestParam(value = &quot;agentId&quot;) Integer agentId) &#123; HashMap&lt;String, Object&gt; result = new HashMap&lt;&gt;(); List&lt;Integer&gt; managerIdList = clubDataDao.queryClubManagerIdByAgencyId(agentId); result.put(&quot;managerIdList&quot;, managerIdList); Integer groupId = gmDataDao.queryGroupIdByAgencyId(agentId); result.put(&quot;groupId&quot;, groupId); return result; &#125;&#125; 使用swagger2测试如下：]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 阻塞队列实现超时机制]]></title>
    <url>%2F2017%2F08%2F25%2Fblockqueue%2F</url>
    <content type="text"><![CDATA[阻塞队列概念定义：阻塞队列 (BlockingQueue)是Java util.concurrent包下重要的数据结构，BlockingQueue提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。BlockingQueue是个接口，实现有ArrayBlockingQueue、DelayQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue。本文使用ArrayBlockingQueue：有界的阻塞队列，内部实现是将对象放到一个数组中。jdk源码为：12345678public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125; 参数capacity为数组容量；fair为true，插入或删除对象时，按FIFO顺序处理。 阻塞队列工具实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.Map;import java.util.UUID;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.TimeUnit;public class BlockQueueUtil &#123; /** * 阻塞队列超时时间,单位秒 */ private static final int TIMEOUT = 5; /** * 全局MAP，一个UUID标识一个阻塞队列 */ public static Map&lt;UUID, BlockingQueue&gt; msgHdMap = new ConcurrentHashMap&lt;&gt;(); /** * 单例 */ private static BlockQueueUtil bqInstance = null; public static BlockQueueUtil getInstance() &#123; if (bqInstance == null) &#123; bqInstance = new BlockQueueUtil(); &#125; return bqInstance; &#125; /** * 新建阻塞队列，放入全局map中 * @return uuid */ public UUID getMsgMap() &#123; UUID uuid = UUID.randomUUID(); BlockingQueue&lt;String&gt; msgqueue = new ArrayBlockingQueue&lt;String&gt;(3, true); msgHdMap.put(uuid, msgqueue); return uuid; &#125; /** * 获取阻塞队列 * @param uuid */ public BlockingQueue getQueue(UUID uuid) &#123; return msgHdMap.get(uuid); &#125; /** * 入队 */ public void queueIn(UUID uuid, String responseStr) &#123; BlockingQueue&lt;String&gt; msgqueue = msgHdMap.get(uuid); msgqueue.add(responseStr); &#125; /** * 出队 * @param uuid */ public String queueOut(UUID uuid) &#123; BlockingQueue&lt;String&gt; msgqueue = msgHdMap.get(uuid); String tac = null; try &#123; tac = msgqueue.poll(TIMEOUT, TimeUnit.SECONDS); &#125; catch (InterruptedException e) &#123; // 超时 e.printStackTrace(); &#125; finally &#123; // recycle map msgHdMap.remove(uuid); &#125; return tac; &#125;&#125; ConcurrentHashMap的key为唯一标志uuid，value为阻塞队列。上述getMsgMap方法创建容量为3的阻塞队列；出队方法queueOut调用poll方法（检索并删除此队列的头），超时时间设置为5秒。 调用发起阻塞，等待事件：12345678BlockQueueUtil queueUtil = BlockQueueUtil.getInstance();UUID uuid = queueUtil.getMsgMap();String tac = queueUtil.queueOut(uuid);if (tac == null) &#123;System.out.println(&quot;timeout....&quot;);&#125; else &#123;your normal logic balabala&#125; 初始，每个阻塞队列为空，执行出队操作，阻塞直到事件触发或者超时。事件触发：1// 阻塞队列，入队 BlockQueueUtil.getInstance().queueIn(UUID.fromString(json.getString(&quot;uuid&quot;)), json.get(&quot;res&quot;).toString()); 入队后，阻塞队列不为空，queueUtil.queueOut(uuid)被触发，执行后续操作your normal logic balabala。阻塞队列的应用场景为线程间通信（如生产者消费者模式）或为网络通信（socket或http）。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java过滤Emoji字符]]></title>
    <url>%2F2017%2F08%2F25%2Ffilter_emoji%2F</url>
    <content type="text"><![CDATA[微信昵称支持Emoji表情，存储微信昵称时，若线上mysql编码未采用utfmb4，依然使用utf-8，向数据库写数据时就要过滤掉昵称中的Emoji表情。过滤emoji可选用以下方法： 方法一：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class EmojiFilter &#123; /** * 检测是否有emoji字符 * @param source * @return 一旦含有就抛出 */ public static boolean containsEmoji(String source) &#123; if (source == null || &quot;&quot;.equals(source)) &#123; return false; &#125; int len = source.length(); for (int i = 0; i &lt; len; i++ ) &#123; char codePoint = source.charAt(i); if (isEmojiCharacter(codePoint)) &#123; // do nothing，判断到了这里表明，确认有表情字符 return true; &#125; &#125; return false; &#125; private static boolean isEmojiCharacter(char codePoint) &#123; return (codePoint == 0x0) || (codePoint == 0x9) || (codePoint == 0xA) || (codePoint == 0xD) || ((codePoint &gt;= 0x20) &amp;&amp; (codePoint &lt;= 0xD7FF)) || ((codePoint &gt;= 0xE000) &amp;&amp; (codePoint &lt;= 0xFFFD)) || ((codePoint &gt;= 0x10000) &amp;&amp; (codePoint &lt;= 0x10FFFF)); &#125; /** * 过滤emoji 或者 其他非文字类型的字符 * @param source * @return */ public static String filterEmoji(String source) &#123; if (!containsEmoji(source)) &#123; return source;// 如果不包含，直接返回 &#125; // 到这里铁定包含 StringBuilder buf = null; int len = source.length(); for (int i = 0; i &lt; len; i++ ) &#123; char codePoint = source.charAt(i); if (isEmojiCharacter(codePoint)) &#123; if (buf == null) &#123; buf = new StringBuilder(source.length()); &#125; buf.append(codePoint); &#125; else &#123;&#125; &#125; if (buf == null) &#123; return source;// 如果没有找到 emoji表情，则返回源字符串 &#125; else &#123; if (buf.length() == len) &#123;// 这里的意义在于尽可能少的toString，因为会重新生成字符串 buf = null; return source; &#125; else &#123; return buf.toString(); &#125; &#125; &#125;&#125; 单元测试如下：12345678public void testEmojiFilter1() &#123; boolean expireRight = true; String predictStr = &quot;An awesome string with a few emojis!&quot;; String nickname= &quot;An 😀awesome 😃string with a few 😉emojis!&quot;; String newNickname = EmojiFilter.filterEmoji(nickname); System.out.println(&quot;newNickname: &quot;+newNickname); assertTrue(&quot;newNickname result: &quot; + newNickname, newNickname.equals(predictStr));&#125; 方法二：如果是maven项目，在pom中引入12345&lt;dependency&gt; &lt;groupId&gt;com.vdurmont&lt;/groupId&gt; &lt;artifactId&gt;emoji-java&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 使用库封装的方法：1String resultStr = EmojiParser.removeAllEmojis(str); EmojiParser提供emoji处理的各种方法，感兴趣自己试下。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring使用hibernate-validator对请求参数校验]]></title>
    <url>%2F2017%2F08%2F24%2FreqModel_bean%2F</url>
    <content type="text"><![CDATA[服务端收到通过拦截器的请求后，第一步，即为对请求参数的合法性校验。合法性校验依次为三部分： 参数是否存在 参数类型是否合法 其他复杂校验 一般的参数校验举例如下：1234567891011121314151617181920public HashMap&lt;String, Object&gt; roleInfo(HttpServletRequest request) &#123; HashMap&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); String roleId; try &#123; roleId = request.getParameter(&quot;id&quot;); &#125; catch (Throwable t) &#123; logger.error(&quot;ProxyController roleInfo args error:&quot; + t); result.put(&quot;result&quot;, StatusCode.ILLEGAL_PARAM.getValue()); result.put(&quot;description&quot;, StatusCode.ILLEGAL_PARAM.getDescription()); return result; &#125; if (!LegalUtil.isLegalRoleId(roleId)) &#123; logger.error(&quot;ProxyController roleinfo roleId error:&quot; + roleId); result.put(&quot;result&quot;, StatusCode.ILLEGAL_PARAM.getValue()); result.put(&quot;description&quot;, StatusCode.ILLEGAL_PARAM.getDescription()); return result; &#125; return proxyService.getRoleInfo(Integer.valueOf(request.getSession().getAttribute(&quot;agencyID&quot;).toString()), Integer.valueOf(roleId)); &#125; 如果采用如下方式接受传入参数，看起来好像可以解决校验臃肿的问题：123456789public HashMap&lt;String, Object&gt; roleInfo(@RequestParam(value = &quot;id&quot;) int id) &#123; if (!LegalUtil.isLegalRoleId(roleId)) &#123; logger.error(&quot;ProxyController roleinfo roleId error:&quot; + roleId); result.put(&quot;result&quot;, StatusCode.ILLEGAL_PARAM.getValue()); result.put(&quot;description&quot;, StatusCode.ILLEGAL_PARAM.getDescription()); return result; &#125; return proxyService.getRoleInfo(Integer.valueOf(request.getSession().getAttribute(&quot;agencyID&quot;).toString()), Integer.valueOf(roleId)); &#125; 但是如果参数过多呢，会导致传入参数按个列出显得过长，而是耦合太紧，也无法复用。统一提出为Model类型，使用hibernate-validator校验（hibernate-validator的引入及注解使用参照官方文档），采用bean注入方式调用，使代码看起来不那么臃肿，层次分明，Model大多时候可以复用，如下所示：12345678910111213141516import javax.validation.constraints.NotNull;import javax.validation.constraints.Pattern;public class RoleInfoReq &#123; @Pattern(regexp = &quot;^[1-9]\\d&#123;6,9&#125;$&quot;, message = &quot;用户id不合法&quot;) @NotNull private String id; public Integer getId() &#123; return Integer.valueOf(id); &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 1234//调用public HashMap&lt;String, Object&gt; roleInfo(@Valid RoleInfoReq reqModel, HttpServletRequest request) &#123; return proxyService.getRoleInfo(Integer.valueOf(request.getSession().getAttribute(&quot;agencyID&quot;).toString()), reqModel.getId()); &#125; 有木有觉得很清爽~复杂的例子如下：提出前：1234567891011121314151617181920212223242526272829303132 public HashMap&lt;String, Object&gt; chargeList(HttpServletRequest request, HttpSession session) &#123; HashMap&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); String idStr; String begintime; String endtime;String currentpage;String pagesize;String totalnum;String flag; try &#123; idStr = request.getParameter(&quot;id&quot;); begintime = request.getParameter(&quot;begintime&quot;); endtime = request.getParameter(&quot;endtime&quot;); currentpage = request.getParameter(&quot;currentpage&quot;); pagesize = request.getParameter(&quot;pagesize&quot;); totalnum = request.getParameter(&quot;totalnum&quot;); flag = request.getParameter(&quot;flag&quot;); &#125; catch (Throwable t) &#123; logger.error(&quot;ChargeController player chargeList args error:&quot; + t); result.put(&quot;result&quot;, StatusCode.ILLEGAL_PARAM.getValue()); result.put(&quot;description&quot;, StatusCode.ILLEGAL_PARAM.getDescription()); return result; &#125; if (!LegalUtil.isLegalIdIncludeZero(idStr) || !LegalUtil.isLegalDate(begintime) || !LegalUtil.isLegalDate(endtime) || !LegalUtil.isDigital(currentpage) || !LegalUtil.isDigital(pagesize) || !LegalUtil.isDigital(totalnum) || !LegalUtil.isDigital(flag)) &#123; result.put(&quot;result&quot;, StatusCode.ILLEGAL_PARAM.getValue()); result.put(&quot;description&quot;, StatusCode.ILLEGAL_PARAM.getDescription()); return result; &#125; 吧啦吧啦。。。 咕噜咕噜。。。 &#125; 提出后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import javax.validation.constraints.Max;import javax.validation.constraints.NotNull;import javax.validation.constraints.Pattern;public class ChargeRecordsCardGivePlayerReq &#123; private final String dateformat = &quot;^(([0-9]&#123;3&#125;[1-9]|[0-9]&#123;2&#125;[1-9][0-9]|[0-9][1-9][0-9]&#123;2&#125;|[1-9][0-9]&#123;3&#125;)-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]&#123;2&#125;)(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29)$&quot;; private final String isDigit = &quot;^[0-9]*$&quot;; /** * 7-10位正整数或0 */ @Pattern(regexp = &quot;^([1-9]\\d&#123;6,9&#125;)|(0)$&quot;, message = &quot;用户id不合法&quot;) @NotNull private String id; /** * 时间格式必须为YYYY-MM-DD */ @Pattern(regexp = dateformat, message = &quot;时间格式不合法&quot;) @NotNull private String begintime; @Pattern(regexp = dateformat, message = &quot;时间格式不合法&quot;) @NotNull private String endtime; @Pattern(regexp = isDigit, message = &quot;当前页，格式不合法&quot;) @Max(Integer.MAX_VALUE) @NotNull private String currentpage; @Pattern(regexp = isDigit, message = &quot;每页记录数，格式不合法&quot;) @Max(Integer.MAX_VALUE) @NotNull private String pagesize; @Pattern(regexp = isDigit, message = &quot;总记录数，格式不合法&quot;) @Max(Integer.MAX_VALUE) @NotNull private String totalnum; @Pattern(regexp = &quot;^1|2$&quot;, message = &quot;房卡类型不合法&quot;) @NotNull private String flag; public String getBegintime() &#123; return begintime; &#125; public void setBegintime(String begintime) &#123; this.begintime = begintime; &#125; public String getEndtime() &#123; return endtime; &#125; public void setEndtime(String endtime) &#123; this.endtime = endtime; &#125; public Integer getCurrentpage() &#123; return Integer.valueOf(currentpage); &#125; public void setCurrentpage(String currentpage) &#123; this.currentpage = currentpage; &#125; public Integer getPagesize() &#123; return Integer.valueOf(pagesize); &#125; public void setPagesize(String pagesize) &#123; this.pagesize = pagesize; &#125; public Integer getTotalnum() &#123; return Integer.valueOf(totalnum); &#125; public void setTotalnum(String totalnum) &#123; this.totalnum = totalnum; &#125; public Integer getFlag() &#123; return Integer.valueOf(flag); &#125; public void setFlag(String flag) &#123; this.flag = flag; &#125; public Integer getId() &#123; return Integer.valueOf(id); &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 12345678//调用public HashMap&lt;String, Object&gt; chargeList(@Valid ChargeRecordsCardGivePlayerReq reqModel, HttpSession session) &#123; if (reqModel.getFlag() == 1) &#123; return chargeService.getGivePlayerRecords(Integer.valueOf(session.getAttribute(&quot;agencyID&quot;).toString()), reqModel.getId(), reqModel.getBegintime(), reqModel.getEndtime(), reqModel.getCurrentpage(), reqModel.getPagesize(), reqModel.getTotalnum()); &#125; else &#123; return chargeService.getGiveManagerRecord(Integer.valueOf(session.getAttribute(&quot;agencyID&quot;).toString()), reqModel.getId(), reqModel.getBegintime(), reqModel.getEndtime(), reqModel.getCurrentpage(), reqModel.getPagesize(), reqModel.getTotalnum()); &#125; &#125; 若参数校验不合法，返回状态码400，出错时间，错误原因等详细信息，对接良好。注意，若为post请求，使用注解@Valid @ModelAttribute1public HashMap&lt;String, Object&gt; chargeList(@Valid @ModelAttribute ChargeRecordsCardGivePlayerReq reqModel, HttpSession session) &#123;&#125; 若为get请求，使用注解@Valid1public HashMap&lt;String, Object&gt; chargeList(@Valid ChargeRecordsCardGivePlayerReq reqModel, HttpSession session) &#123;&#125; 模拟单纯发http请求，不走浏览器，使用curl或者postman，curl可以看到请求的详细过程，postman图形界面且有历史记录，开发中推荐使用curl，两者皆可。如以上的chargeList函数的参数校验，模拟请求：1234567891011121314151617#正确输入curl -v http://127.0.0.1:8091/guiyang/agentboot/charge/records/card/give/player?id=1234567&quot;&amp;&quot;begintime=2017-01-01&quot;&amp;&quot;endtime=2018-01-01&quot;&amp;&quot;currentpage=1&quot;&amp;&quot;pagesize=1&quot;&amp;&quot;totalnum=1&quot;&amp;&quot;flag=1#缺少参数curl -v http://127.0.0.1:8091/guiyang/agentboot/charge/records/card/give/player?id=1234567&quot;&amp;&quot;begintime=2017-01-01&quot;&amp;&quot;endtime=2018-01-01&quot;&amp;&quot;pagesize=1&quot;&amp;&quot;totalnum=1&quot;&amp;&quot;flag=1#用户id不合法curl -v http://127.0.0.1:8091/guiyang/agentboot/charge/records/card/give/player?id=124534567&quot;&amp;&quot;begintime=2017-01-01&quot;&amp;&quot;endtime=2018-01-01&quot;&amp;&quot;currentpage=1&quot;&amp;&quot;pagesize=1&quot;&amp;&quot;totalnum=1&quot;&amp;&quot;flag=1#时间格式不合法curl -v http://127.0.0.1:8091/guiyang/agentboot/charge/records/card/give/player?id=1234567&quot;&amp;&quot;begintime=2017-01-01&quot;&amp;&quot;endtime=2018-0101&quot;&amp;&quot;currentpage=1&quot;&amp;&quot;pagesize=1&quot;&amp;&quot;totalnum=1&quot;&amp;&quot;flag=1#总数量格式不合法curl -v http://127.0.0.1:8091/guiyang/agentboot/charge/records/card/give/player?id=1234567&quot;&amp;&quot;begintime=2017-01-01&quot;&amp;&quot;endtime=2018-01-01&quot;&amp;&quot;currentpage=-1&quot;&amp;&quot;pagesize=1&quot;&amp;&quot;totalnum=1&quot;&amp;&quot;flag=1#卡类型不合法curl -v http://127.0.0.1:8091/guiyang/agentboot/charge/records/card/give/player?id=1234567&quot;&amp;&quot;begintime=2017-01-01&quot;&amp;&quot;endtime=2018-01-01&quot;&amp;&quot;currentpage=1&quot;&amp;&quot;pagesize=1&quot;&amp;&quot;totalnum=1&quot;&amp;&quot;flag=0 请求格式统一提出Model，同样地，返回格式也可统一格式，提出Model，这块不多介绍，感兴趣的尝试一下。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中RSA的使用]]></title>
    <url>%2F2017%2F08%2F20%2Frsa_java%2F</url>
    <content type="text"><![CDATA[RSA为非对称加密，根据应用场景不同，分如下两种：1.签名：使用私钥加密，公钥解密。用于验证私钥持有者的身份，防止私钥所有者发布的内容被篡改，但是公钥一般是公开的，所以无法保证加密内容不被其他人获得。2.加密：公钥加密，私钥解密。加密内容无法被他人获得，但是信息可能被他人篡改伪造。以下为Java中RSA算法的实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193public class RSACoder &#123; public static final String KEY_ALGORITHM = &quot;RSA&quot;; public static final String SIGNATURE_ALGORITHM = &quot;MD5withRSA&quot;; private static final String PUBLIC_KEY = &quot;RSAPublicKey&quot;; private static final String PRIVATE_KEY = &quot;RSAPrivateKey&quot;; /** * 初始化密钥 * * @return * @throws Exception */ public static Map&lt;String, Object&gt; initKey() throws Exception &#123; KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM); keyPairGen.initialize(512); KeyPair keyPair = keyPairGen.generateKeyPair(); // 公钥 RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); // 私钥 RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, Object&gt; keyMap = new HashMap&lt;String, Object&gt;(2); keyMap.put(PUBLIC_KEY, publicKey); keyMap.put(PRIVATE_KEY, privateKey); return keyMap; &#125; /** * 取得私钥 * * @param keyMap * @return * @throws Exception */ public static String getPrivateKey(Map&lt;String, Object&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PRIVATE_KEY); return encryptHex(key.getEncoded()); &#125; /** * 取得公钥 * * @param keyMap * @return * @throws Exception */ public static String getPublicKey(Map&lt;String, Object&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PUBLIC_KEY); return encryptHex(key.getEncoded()); &#125; /** * from koduser 加密&lt;br&gt; * 用私钥加密 * * @param data * @param key * @return * @throws Exception */ public static byte[] encryptByPrivateKey(byte[] data, String key) throws Exception &#123; // 对密钥解密 byte[] keyBytes = decryptHex(key); // 取得私钥 PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, privateKey); return cipher.doFinal(data); &#125; /** * 用私钥解密 * * @param data * @param key * @return * @throws Exception */ public static byte[] decryptByPrivateKey(byte[] data, String key) throws Exception &#123; byte[] keyBytes = decryptHex(key); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateKey); return cipher.doFinal(data); &#125; /** * 用公钥加密 * * @param data * @param key * @return * @throws Exception */ public static byte[] encryptByPublicKey(byte[] data, String key) throws Exception &#123; byte[] keyBytes = decryptHex(key); // 取得公钥 X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicKey = keyFactory.generatePublic(x509KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, publicKey); return cipher.doFinal(data); &#125; /** * 用公钥解密 * * @param data * @param key * @return * @throws Exception */ public static byte[] decryptByPublicKey(byte[] data, String key) throws Exception &#123; byte[] keyBytes = decryptHex(key); // 取得公钥 X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicKey = keyFactory.generatePublic(x509KeySpec); // 对数据解密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, publicKey); return cipher.doFinal(data); &#125; /** * 用私钥来签名 * * @param data * @param privateKey * @return * @throws Exception */ public static String sign(byte[] data, String privateKey) throws Exception &#123; byte[] keyBytes = decryptHex(privateKey); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initSign(priKey); signature.update(data); return encryptHex(signature.sign()); &#125; /** * 用公钥来验签 * * @param data * @param publicKey * @param sign * @return * @throws Exception */ public static boolean verify(byte[] data, String publicKey, String sign) throws Exception &#123; byte[] keyBytes = decryptHex(publicKey); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PublicKey pubKey = keyFactory.generatePublic(keySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initVerify(pubKey); signature.update(data); return signature.verify(decryptHex(sign)); &#125;&#125; 测试以上方法如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 私钥签名，公钥验签 */public void testSignVerify() throws Exception &#123; Map&lt;String, Object&gt; key = RSACoder.initKey(); String publicKey = RSACoder.getPublicKey(key); String privateKey = RSACoder.getPrivateKey(key); String data = &quot;testData&quot;; String sign = RSACoder.sign(data.getBytes(), privateKey); RSACoder.verify(data.getBytes(), publicKey, sign); assertTrue(RSACoder.verify(data.getBytes(), publicKey, sign));&#125;/** * 私钥加密，公钥解密 * * @throws Exception */public void testPrivateEncryt() throws Exception &#123; Map&lt;String, Object&gt; key = RSACoder.initKey(); String publicKey = RSACoder.getPublicKey(key); String privateKey = RSACoder.getPrivateKey(key); String data = &quot;testDataPrivate&quot;; byte[] encryDataByte = RSACoder.encryptByPrivateKey(data.getBytes(), privateKey); byte[] decryDataByte = RSACoder.decryptByPublicKey(encryDataByte, publicKey); String decryData = new String(decryDataByte); System.out.println(decryData); assertTrue(decryData.equals(data));&#125;/** * 公钥加密，私钥解密 */public void testPublicEncryt() throws Exception &#123; Map&lt;String, Object&gt; key = RSACoder.initKey(); String publicKey = RSACoder.getPublicKey(key); String privateKey = RSACoder.getPrivateKey(key); String data = &quot;testDataPublic&quot;; byte[] encryDataByte = RSACoder.encryptByPublicKey(data.getBytes(), publicKey); byte[] decryDataByte = RSACoder.decryptByPrivateKey(encryDataByte, privateKey); String decryData = new String(decryDataByte); System.out.println(decryData); assertTrue(decryData.equals(data));&#125; 一般使用私钥签名，将签名内容一同发送给接收者验签，这样保证了发送者的身份有效性（服务器A给服务器B发送内容，使用服务器A的公钥私钥）。如果公钥不对外暴露，服务器之间采用相互信任的机制，各自保留对方的公钥，那么可采取公钥加密私钥解密的方式（服务器A给服务器B发送内容，使用服务器B的公钥私钥）。注：加解密参数及结果经常为字节数组，此时涉及字节数组与字符串的比较，那么就要转换类型。String a转byte[] b为方法为a.getBytes(),getBytes()参数为编码类型，无参则使用环境编码（Charset.defaultCharset()查看当前系统编码），从jdk源码看，若编码不支持，则使用ISO-8859-1编码，建议制定兼容的UTF-8编码。byte[] b转String a的方法为new String(b),同样可指定编码，切勿使用b.toString(),字节数组未覆盖Object的toString方法，toString()获得的是内存地址（也非实际物理地址，只是约定为getClass().getName() + “@” + Integer.toHexString(hashCode())）。 拓展推荐一个Java工具类，功能强大，其中封装了各种加解密方法。简单测试其AES算法为123456789public void testAESHex() throws UnsupportedEncodingException &#123; String content = &quot;justForTest&quot;; byte[] key = SecureUtil.generateKey(SymmetricAlgorithm.AES.getValue()).getEncoded(); System.out.println(&quot;key length: &quot; + key.length); SymmetricCrypto aes = new SymmetricCrypto(SymmetricAlgorithm.AES, key); String encryptHex = aes.encryptHex(content); String decrypt = aes.decryptStr(encryptHex, CharsetUtil.CHARSET_UTF_8); assertTrue(decrypt.equals(content));&#125; aes加解密encryptHex对应decryptStr，encrypt对应decrypt，以上key为工具类生成的，若自己指定key，则key必须为16、24、32位等，如下ct为毫秒级的Unix时间戳，只有13位，为凑足16位，随机加上3位，如”123”:12345678910public void testAES1() throws UnsupportedEncodingException &#123; String content = &quot;justForTest&quot;; long ct = System.currentTimeMillis(); //13位 String key = String.valueOf(ct) + &quot;123&quot;; SymmetricCrypto aes = new SymmetricCrypto(SymmetricAlgorithm.AES, key.getBytes(&quot;ISO-8859-1&quot;)); byte[] encrypt = aes.encrypt(content); byte[] decrypt = aes.decrypt(encrypt); String result = new String(decrypt, &quot;ISO-8859-1&quot;); assertTrue(result.equals(content));&#125;]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql分页]]></title>
    <url>%2F2017%2F08%2F17%2Fpaging_mysql%2F</url>
    <content type="text"><![CDATA[mysql使用limit，offset实现分页。limt 3 offset 5 效果同 limit 5,3都表示偏移5，从第6条开始读，读3条记录。示例如下:12345678910selectdate_format(createTime, &quot;%Y-%m-%d %T&quot;) as time,buyerId,commissionfrompartner_commission_recordwheredate_format(createTime, &quot;%Y-%m-%d&quot;) between #&#123;date_from&#125; and #&#123;date_to&#125;and agencyId = #&#123;agencyId&#125; and (rebateLV=1 or rebateLV=2) and isCancel=0order bycreateTime desclimit #&#123;limit&#125; offset #&#123;offset&#125;; ORM使用Mybatis则建议使用Mybatis的动态sql语句，通过标签实现不同情形的sql复用。示例如下:12345678910111213141516171819&lt;select id=&quot;addCardPlayerRecord&quot; parameterType=&quot;HashMap&quot; resultType=&quot;HashMap&quot;&gt; select playerID,amount,date_format(time, &quot;%Y-%m-%d %T&quot;) as time from add_player_card_log where agency = #&#123;agencyID&#125; &lt;if test=&quot;null!=playerID&quot;&gt; and playerID = #&#123;playerID&#125; &lt;/if&gt; &lt;if test=&quot;null!=date_from and null!=date_to&quot;&gt; and date_format(time, &quot;%Y-%m-%d&quot;) between #&#123;date_from&#125; and #&#123;date_to&#125; &lt;/if&gt; order by add_player_card_log.time desc &lt;if test=&quot;null!=limit and null!=offset&quot;&gt; limit #&#123;limit&#125; offset #&#123;offset&#125;; &lt;/if&gt;&lt;/select&gt;]]></content>
      <tags>
        <tag>技术</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql插入测试数据示例]]></title>
    <url>%2F2017%2F08%2F08%2Fmysql_insert%2F</url>
    <content type="text"><![CDATA[在接口自测及联调阶段，需要伪造数据供测试使用，以如下简单程序示例循环插入数据：1234567891011121314drop procedure if exists test_insert;DELIMITER //create procedure test_insert()begindeclare i int;set i = 1000;while i&lt;1050 doinsert into account(agencyID,userName,referrer,account,weixin,card,createTime,verification,status,payStatus,firstLoginStatus) values(i,concat(&quot;test&quot;,i),2002428,concat(18841000,i),concat(&quot;testweixin&quot;,i),1000,date(now()),1,3,1,1);set i = i+1;end while;end //DELIMITER ;call test_insert(); 注释：DELIMITER作用是告诉Mysql解释器，该段命令是否已经结束。默认情况下，delimiter是分号;mysql一遇到分号，就要自动执行，所以需要事先把delimiter换成其它符号，如//或$$，最后再重置为默认值。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简谈mysql中utf8mb4]]></title>
    <url>%2F2017%2F08%2F06%2Futf8mb4%2F</url>
    <content type="text"><![CDATA[最近开发遇到当Mysql存储微信昵称,而微信昵称有emoji表情符号时，数据库存储数据出现乱码。原因是mysql支持的utf8编码最大长度为3字节，如果遇4字节的宽字符(emoji表情符号、不常用的汉字、新增的Unicode字符等)就会插入异常。Mysql在5.5.3之后增加utf8mb4（most bytes 4）编码,专门用于兼容四字节的unicode，一般情况。为了节省空间，使用utf8即可，但是建议使用utf8mb4。 Linux下更改mysql编码方式使用Linux的发行版本为Centos 首先查看mysql版本，是否支持utf8mb4（5.5.3版本及以上）。查看版本简易方法：终端下：mysql -Vmysql下:status; 或 select version(); 修改mysql配置文件修改my.conf(windows下为my.ini)修改前后的配置文件及系统编码分别如下：修改前编码：修改前配置文件：修改后的编码：修改后的配置文件： 修改database、table及column的字符集123ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;ALTER TABLE table_name CHANGE column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 重启mysql1service mysql restart 或 systemctl restart mysqld.service 若更新sql，指定编码方式为utf8mb41mysql -uyourName -pyourPassword --default-character-set=utf8mb4 mahjongforagency &lt; /root/update.sql]]></content>
      <tags>
        <tag>技术</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java解析xml]]></title>
    <url>%2F2017%2F07%2F08%2Fjava_xml%2F</url>
    <content type="text"><![CDATA[如下xml为例：123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;datasoruce&gt; &lt;property name=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;url&quot;&gt; jdbc:mysql://127.0.0.1:3306/poker?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=true &lt;/property&gt; &lt;property name=&quot;username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt;&lt;/datasoruce&gt; 解析引入dom4j,这里使用的为2.0.0版本，具体文档到社区查看，github已有最新2.0.1版本，dom4j更新很慢，也可以说比较稳定。import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;日志输出使用：import org.slf4j.Logger;import org.slf4j.LoggerFactory;解析类如下：12345678910111213141516171819202122232425262728public class XmlParser&#123; private static final Logger logger = LoggerFactory.getLogger(XmlParser.class); public static HashMap&lt;String, String&gt; parse(InputStream inputStream) &#123; SAXReader reader = new SAXReader(); Document document = null; try &#123; document = reader.read(inputStream); &#125; catch (DocumentException e) &#123; logger.error(&quot;parse xml error: &#123;&#125;&quot;, e); &#125; Element root = document.getRootElement(); List nodes = root.elements(&quot;property&quot;); Iterator&lt;Element&gt; it = nodes.iterator(); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); while (it.hasNext()) &#123; Element element = it.next(); map.put(element.attribute(&quot;name&quot;).getText(), element.getStringValue()); &#125; return map; &#125;&#125; 外层调用：12InputStream inputStream = DbManager.class.getResourceAsStream(&quot;/datasource.xml&quot;);HashMap&lt;String, String&gt; map = XmlParser.parse(inputStream); 另外，如果验证拿到xml的合法性，则如下，将输入流解析为字符流输出，引入com.google.common.io.CharStreams;12345678910// 输出连接数据库的配置文件InputStream inputStream = DbManager.class.getResourceAsStream(&quot;/datasource.xml&quot;);try &#123; String text = CharStreams.toString(new InputStreamReader(inputStream, &quot;UTF-8&quot;)); logger.info(&quot;dataSource.xml str: \n&#123;&#125;&quot;,text);&#125; catch (IOException e) &#123; logger.error(&quot;dataSource.xml IOException e -&gt;&#123;&#125;&quot;, e);&#125;inputStream = DbManager.class.getResourceAsStream(&quot;/datasource.xml&quot;);HashMap&lt;String, String&gt; map = XmlParser.parse(inputStream); String text = CharStreams.toString(new InputStreamReader(inputStream, “UTF-8”));已经将输入流读取完毕,已到流的结尾，不可直接再次使用。需重新获取inputStream = DbManager.class.getResourceAsStream(“/datasource.xml”); 补充，上一步执行了两次inputStream = DbManager.class.getResourceAsStream(“/datasource.xml”);效率很低,看起来也很傻。又看了下inputStream有mark/reset方法，解决了我的问题。如下：1234567891011inputStream = DbManager.class.getResourceAsStream(&quot;/datasource.xml&quot;);try &#123; // inputStream.markSupported(); inputStream.mark(inputStream.available()); String text = CharStreams.toString(new InputStreamReader(inputStream, &quot;UTF-8&quot;)); inputStream.reset(); logger.info(&quot;dataSource.xml str: \n&#123;&#125;&quot;,text);&#125; catch (IOException e) &#123; logger.error(&quot;dataSource.xml IOException e -&gt;&#123;&#125;&quot;, e);&#125;HashMap&lt;String, String&gt; map = XmlParser.parse(inputStream); InputStream本身提供三个接口 markSupported()；InputStream是否支持mark，默认不支持 mark(int readLimit);用于标记当前位置，在读取一定数量的数据(小于readlimit的数据)后使用reset可以回到mark标记的位置。 reset()；回到mark标记位置。 子类需要支持mark必须重写这三个方法。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js解析xml]]></title>
    <url>%2F2017%2F07%2F06%2Fjs_xml%2F</url>
    <content type="text"><![CDATA[js解析xml字符串示例为DOMParser.parseFromString()的简单使用。以下用到ES6的多行字符串，注意包含str值的两个点是Tab键上面、数字键1左边的按键，而不是单引号。1234567891011121314151617181920212223242526272829303132333435function testXmlStr()&#123; var str = `&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt; &lt;province name=&quot;北京直辖市&quot;&gt; &lt;city&gt;昌平区&lt;/city&gt; &lt;city&gt;朝阳区&lt;/city&gt; &lt;city&gt;崇文区&lt;/city&gt; &lt;city&gt;大兴区&lt;/city&gt; &lt;city&gt;东城区&lt;/city&gt; &lt;city&gt;房山区&lt;/city&gt; &lt;city&gt;丰台区&lt;/city&gt; &lt;city&gt;海淀区&lt;/city&gt; &lt;city&gt;怀柔区&lt;/city&gt; &lt;city&gt;门头沟区&lt;/city&gt; &lt;city&gt;密云区&lt;/city&gt; &lt;city&gt;平谷区&lt;/city&gt; &lt;city&gt;石景山区&lt;/city&gt; &lt;city&gt;顺义区&lt;/city&gt; &lt;city&gt;通州区&lt;/city&gt; &lt;city&gt;西城区&lt;/city&gt; &lt;city&gt;宣武区&lt;/city&gt; &lt;city&gt;延庆区&lt;/city&gt; &lt;/province&gt;&lt;/root&gt;`; //创建文档对象 var parser=new DOMParser(); var xmlDoc=parser.parseFromString(str,&quot;text/xml&quot;); //提取数据 var countrys = xmlDoc.getElementsByTagName(&apos;city&apos;); var arr = []; //输出数据 for (var i = 0; i &lt; countrys.length; i++) &#123; arr.push(countrys[i].textContent); &#125;; console.log(arr);&#125; js解析本地xml文件要解析的xml文件部分数据如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt; &lt;province name=&quot;北京直辖市&quot;&gt; &lt;city&gt;昌平区&lt;/city&gt; &lt;city&gt;朝阳区&lt;/city&gt; &lt;city&gt;崇文区&lt;/city&gt; &lt;city&gt;大兴区&lt;/city&gt; &lt;city&gt;东城区&lt;/city&gt; &lt;city&gt;房山区&lt;/city&gt; &lt;city&gt;丰台区&lt;/city&gt; &lt;city&gt;海淀区&lt;/city&gt; &lt;city&gt;怀柔区&lt;/city&gt; &lt;city&gt;门头沟区&lt;/city&gt; &lt;city&gt;密云区&lt;/city&gt; &lt;city&gt;平谷区&lt;/city&gt; &lt;city&gt;石景山区&lt;/city&gt; &lt;city&gt;顺义区&lt;/city&gt; &lt;city&gt;通州区&lt;/city&gt; &lt;city&gt;西城区&lt;/city&gt; &lt;city&gt;宣武区&lt;/city&gt; &lt;city&gt;延庆区&lt;/city&gt; &lt;/province&gt; &lt;province name=&quot;上海直辖市&quot;&gt; &lt;city&gt;宝山区&lt;/city&gt; &lt;city&gt;长宁区&lt;/city&gt; &lt;city&gt;崇明县&lt;/city&gt; &lt;city&gt;奉贤区&lt;/city&gt; &lt;city&gt;虹口区&lt;/city&gt; &lt;city&gt;黄浦区&lt;/city&gt; &lt;city&gt;嘉定区&lt;/city&gt; &lt;city&gt;金山区&lt;/city&gt; &lt;city&gt;静安区&lt;/city&gt; &lt;city&gt;卢湾区&lt;/city&gt; &lt;city&gt;闵行区&lt;/city&gt; &lt;city&gt;南汇区&lt;/city&gt; &lt;city&gt;浦东新区&lt;/city&gt; &lt;city&gt;普陀区&lt;/city&gt; &lt;city&gt;青浦区&lt;/city&gt; &lt;city&gt;松江区&lt;/city&gt; &lt;city&gt;徐汇区&lt;/city&gt; &lt;city&gt;杨浦区&lt;/city&gt; &lt;city&gt;闸北区&lt;/city&gt; &lt;/province&gt;&lt;/root&gt; 解析内容放到二维数组中，代码如下：123456789101112131415161718192021222324if (window.XMLHttpRequest)&#123; // code for IE7+, Firefox, Chrome, Opera, Safarixmlhttp=new XMLHttpRequest();&#125;else&#123; // code for IE6, IE5xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;xmlhttp.open(&quot;GET&quot;,&quot;example.xml&quot;,false);xmlhttp.send();xmlDoc=xmlhttp.responseXML;console.log(xmlDoc);var arr=[];var x=xmlDoc.getElementsByTagName(&quot;province&quot;);var arr=new Array(x.length);Array.from(x).forEach( function(el, index) &#123; if(arr[index]==undefined)&#123; arr[index]=[]; &#125; Array.from(el.getElementsByTagName(&quot;city&quot;)).forEach(function (e,i) &#123; arr[index].push(e.childNodes[0].nodeValue); &#125;)&#125;);console.log(arr); open方法三个参数分别为http请求方式、请求地址、同步（false,阻塞，不使用异步）还是异步（true）; send方法用于post传递参数，本例未用到，默认为null。如xmlhttp.send(“data=data&amp;data2=data2”); responseXML属性返回XML文档对象; xmlDoc.getElementsByTagName得到的是Dom对象，不可使用forEach,使用Array.from(x)创建数组实例; Array.from()的参数为类似数组或者可迭代的对象，只要有length属性的方法均可作为参数; js解析ajax请求返回的文档对象使用jquery的ajax方法，将返回对象解析到json中，如下：1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;解析xml文件&lt;/title&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt;console.log(&apos;****************************************************************&apos;);$.ajax(&#123; type: &quot;GET&quot;, url: &quot;https://pay.heepay.com/API/PayTransit/QueryProvincesAndCities.aspx&quot;, dataType: &quot;xml&quot;, success: function (ResponseText) &#123; var json=&#123;&#125;; Array.from(ResponseText).forEach( function(el, index) &#123; if(json[el.getAttribute(&apos;name&apos;)]==undefined)&#123; json[el.getAttribute(&apos;name&apos;)]=[]; &#125; Array.from(el.getElementsByTagName(&quot;city&quot;)).forEach(function (e,i) &#123; json[el.getAttribute(&apos;name&apos;)].push(e.childNodes[0].nodeValue); &#125;) &#125;); console.log(json); &#125;&#125;);&lt;/script&gt;&lt;/html&gt; 控制台查看返回如下，跨域，不可访问。12XMLHttpRequest cannot loadNo &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;null&apos; is therefore not allowed access. 而用java，httpClient请求（用的Apache HttpClient 4.5.2），可以拿到该资源。浏览器输入网址可以访问，用postMan也可访问，唯有ajax不可访问。于是查了下，才想起来浏览器的同源策略导致Ajax只能同源使用。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.IOException;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpOptions;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;public class TestMain&#123; public static void main(String[] args)&#123; String url = &quot;https://pay.heepay.com/API/PayTransit/QueryProvincesAndCities.aspx&quot;; String result = doGet(url); System.out.println(result); &#125; public static String doGet(String url) &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); CloseableHttpResponse response = null; String result = &quot;&quot;; HttpGet httpGet = new HttpGet(url); try &#123; response = httpclient.execute(httpGet); if (response.getStatusLine().getStatusCode() == 200) &#123; HttpEntity entity = response.getEntity(); result = EntityUtils.toString(entity); EntityUtils.consume(entity); &#125; &#125; catch (Exception e) &#123; e.getStackTrace(); &#125; finally &#123; try &#123; if (response != null) response.close(); httpclient.close(); &#125; catch (IOException e) &#123; &#125; &#125; return result; &#125;&#125; 浏览器的同源安全策略同源安全策略是浏览器最核心也是最基本的安全机制。同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键安全机制，为了保证用户信息的安全，防止恶意的网站窃取数据。比如A网站设置的 Cookie，由于同源策略，B网站就不能打开或修改。设想如下情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，信息就会泄漏，其他网站就可以冒充用户，为所欲为。同源的定义： 协议相同 域名相同 端口相同 跨域需要双端协作，本文用的接口没有服务端控制权，只有前端单方面无法解决跨域问题，ajax不可请求该资源。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-boot集成Swagger2]]></title>
    <url>%2F2017%2F07%2F05%2Fswagger2%2F</url>
    <content type="text"><![CDATA[Swagger用于定义API文档，实现前后端开发分离，测试时不再需要浏览器输入URL访问Controller。对于post请求，无需使用postman模拟，在接口文档中填参数，可直接模拟发请求。本文介绍Swagger2的引入及常用注解。 pom.xml中添加依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; 引入Swagger2新建类，注解方式引入Swagger212345678910111213141516171819202122232425@Configuration@EnableSwagger2public class Swagger2 &#123; public static Contact contact = new Contact(&quot;引入swagger2&quot;,&quot;http://monkeybean.cn/&quot;,&quot;monkeybean_zhang@163.com&quot;); @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.kodgames.pokeragent&quot;)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;) .description(&quot;swagger2 接口文档&quot;) .termsOfServiceUrl(&quot;http://monkeybean.cn/&quot;) .contact(contact) .version(&quot;1.0&quot;) .build(); &#125;&#125; Controller中添加注解举例：1234567891011/** * 查询用户是否为代理 */@ApiOperation(value=&quot;查询用户是否为代理商&quot;)@ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户id&quot;, required = true, dataType = &quot;Integer&quot;,paramType = &quot;query&quot;)@ApiResponses(value = &#123;@ApiResponse(code = -1,message = &quot;用户不存在&quot;),@ApiResponse(code = -20,message = &quot;代理商被封号&quot;),@ApiResponse(code = -23,message = &quot;当前用户已提交申请，且申请处于审核中&quot;)&#125;)@RequestMapping(path = &quot;agent/is_agent&quot;, method = RequestMethod.GET)public HashMap&lt;String, Object&gt; isAgent(@RequestParam(value = &quot;id&quot;) int accountId)&#123; return service.isAgent(accountId);&#125; 示例说明：1.@ApiOperation：用在方法上，说明方法的作用，再比如：1@ApiOperation(value=&quot;查询返还明细&quot;, notes=&quot;下级id不支持模糊搜索&quot;) 2.@ApiImplicitParams：用在方法上包含一组参数说明如：123456@ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户id&quot;, required = true, dataType = &quot;Integer&quot;,paramType = &quot;query&quot;), @ApiImplicitParam(name = &quot;phone_number&quot;, value = &quot;手机号&quot;, required = true, dataType = &quot;String&quot;,paramType = &quot;query&quot;), @ApiImplicitParam(name = &quot;validcode&quot;, value = &quot;验证码&quot;, required = true, dataType = &quot;String&quot;,paramType = &quot;query&quot;), @ApiImplicitParam(name = &quot;advantages&quot;, value = &quot;个人优势&quot;, required = true, dataType = &quot;String&quot;,paramType = &quot;query&quot;) &#125;) 3.@ApiImplicitParam：用在@ApiImplicitParams注解中，对单个参数进行说明 name：参数名 value：参数含义 required：参数是否必须传 defaultValue：参数默认值 dataType：参数类型（对象类型，基本类型要使用包装类） paramType：参数放在哪个位置 header–&gt;放在header中，请求参数获取方法：@RequestHeader query–&gt;放在url中，请求参数获取方法：@RequestParam path（用于restful接口）–&gt;请求参数获取方法：@PathVariable，示例如下，重点为{} 123456@ApiOperation(value=&quot;获取用户详细信息&quot;, notes=&quot;根据url的id来获取用户详细信息&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;, paramType = &quot;path&quot;) @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; return users.get(id); &#125; body及form不常用 @ApiResponses：用于表示一组响应 @ApiResponse：用在@ApiResponses中，表示单个错误响应信息 code：错误码 message：错误码含义 response：抛出异常的类 常用补充： @Api：用在类上，说明该类的作用如： 123@Api(value= &quot;代理商相关api&quot;)public class ProxyController&#123;&#125; @ApiModel：描述一个Model的信息（一般用于post创建时，使用@RequestBody，请求参数无法使用@ApiImplicitParam注解进行描述） @ApiModelProperty：描述单个model的属性 @PathVariable： 从url模板取值,注意{}；若方法参数名称和绑定的uri template中变量名不一致，需要在@PathVariable(“name”)指定uri template中的名称。如： 1234567@RequestMapping(&quot;/user/&#123;id&#125;&quot;) public void userInfo(@PathVariable int id) &#123; &#125;@RequestMapping(&quot;/user/&#123;id&#125;&quot;) public void userInfo(@PathVariable(name=&quot;id&quot;) int roleId) &#123; &#125; @RequestHeader: 请求header部分的值绑定到方法的参数上 @CookieValue：Request header中关于cookie的值绑定到方法的参数上访问api接口文档输入http://172.16.2.163:8080/swagger-ui.html 访问路径为swagger-ui.html.上一步骤中的查询用户是否为代理的示例效果如下： 安全性api接口文档在内部联调时使用不会有什么问题，正式上线时涉及到安全问题，肯定不可随意访问，后台接口不可暴露。可采用如下安全方案：1.将启用Swagger2的注解注释掉。进入页面时，服务器不会将任何接口返回给浏览器，浏览器拿到的是无任何接口的空页面。效果如下：2.多数情况在上线后仍想访问后台API，则使用拦截器，过滤tokenKey。访问Url如http://172.16.2.163:8080/swagger-ui.html?sdfhiohsdabfnjkawe78oih4342598as1234567891011121314// 请求Swagger2使用key单独过滤if(httpServletRequest.getServletPath().toLowerCase().contains(&quot;swagger&quot;) || httpServletRequest.getServletPath().toLowerCase().contains(&quot;api-docs&quot;))&#123; if(httpServletRequest.getServletPath().toLowerCase().contains(&quot;/swagger-ui.html&quot;)) &#123; if(!httpServletRequest.getQueryString().toLowerCase().contains(&quot;sdfhiohsdabfnjkawe78oih4342598as&quot;)) &#123; httpServletResponse.setStatus(401); return; &#125; &#125; chain.doFilter(httpServletRequest, httpServletResponse); return;&#125;]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-boot打包]]></title>
    <url>%2F2017%2F07%2F02%2Fjar_war%2F</url>
    <content type="text"><![CDATA[Spring-boot相比SpringMVC，基本干掉了繁琐的配置文件，Spring-boot自动完成默认配置。若有自定义配置，在application.properties配置文件覆盖即可。Spring-boot内置tomcat，部署时打成jar包，放到线上启动即可，但独立服务，包文件较大。若多个Spring-boot想使用同一个tomcat或者运维要求Spring-boot项目同其他web项目放到同一容器里，则要考虑打成war包。使用Maven进行项目管理及构建，打包类型配置在依赖文件pom.xml指明。 打成jar包1.声明打包类型为jar1&lt;packaging&gt;jar&lt;/packaging&gt; 2.使用命令 mvn clean package打包部署后，执行1nohup java -jar PokerAgentServer.jar &gt;/dev/null 2&gt;&amp;1 &amp; nohup 表示后台运行，结尾&amp;保证nohup正常运行。&gt;/dev/null 2&gt;&amp;1表示不生成nohup.out文件。声明运行依赖其他类的路径，例如类库及配置文件，则使用-classpath或简写-cp命令，使用此参数则不能使用-jar,-jar会忽略-cp指定的路径1nohup java -cp ../dist/*:../lib/*:../resource org.springframework.boot.loader.JarLauncher &gt;/dev/null 2&gt;&amp;1 &amp; 3.若进行远程调试，使用如下命令：1nohup java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8091 -jar PokerAgentServer.jar &amp; 或1nohup java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8091 -cp ../dist/*:../lib/*:../resource org.springframework.boot.loader.JarLauncher &gt;/dev/null 2&gt;&amp;1 &amp; Host为远程主机地址。开启8091端口。 4.Spring-boot打包会将配置一并达到jar包中，此时需要将resource中的文件删除，再执行mvn clean package打包。启动时，-cp声明依赖的配置文件。1nohup java -cp ../dist/*:../lib/*:../resource org.springframework.boot.loader.JarLauncher &gt;/dev/null 2&gt;&amp;1 &amp;` -jar与-cp有冲突。如果使用-jar选项，java.exe会忽略-cp。这里入口类是org.springframework.boot.loader.JarLauncher，将jar包解压，打开META-INF/MANIFEST.MF文件，如下： 5.每次输入命令启动太麻烦，我一般通过sh文件或者python脚本启动。 打成war包1.修改pom文件中jar为war1&lt;packaging&gt;war&lt;/packaging&gt; 2.修改pom，排除tomcat插件12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 3.使用命令 mvn clean package 打包后，同一般J2EE项目一样部署到web容器。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-boot 定时任务]]></title>
    <url>%2F2017%2F06%2F25%2Fschedule%2F</url>
    <content type="text"><![CDATA[定时任务在开发中很常见，最近在清理数据库废弃数据时用到定时任务。Spring-boot定时任务如下： 修改入口程序12345678910111213141516171819202122232425262728@SpringBootApplication@EnableSchedulingpublic class MainApplication &#123; private static Logger logger = LoggerFactory.getLogger(MainApplication.class); public static void main(String[] args) &#123; PokerAgentServerConfig.getInstance().requestConfig(); SpringApplication.run(MainApplication.class, args); PokerAgentServerConfig.getInstance().initLogback(); &#125; // 配置filter实现前端的跨域访问 @Bean public FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new CrossOriginFilter()); registration.addUrlPatterns(&quot;/*&quot;); return registration; &#125; @Bean public FilterRegistrationBean filterTokenKeyBean() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new TokenKeyFilter()); registration.addUrlPatterns(&quot;/*&quot;); return registration; &#125;&#125; 不必紧张，Logger为日志相关。两个Bean分别是实现跨域访问和token过滤的。启动定时任务只需这一句：1@EnableScheduling 新建定时任务类123456789101112@Componentpublic class MyTimer &#123; private static TempTokenDao agentInfoDao = DbManager.create(TempTokenDao.class); /** * 每天凌晨四点清理一次temptoken表 */ @Scheduled(cron = &quot;0 0 4 * * ?&quot;) public void clearTempToken()&#123; agentInfoDao.deleteAll(); &#125;&#125; 注意： 需要在定时任务的类上加上注释：@Component，在具体的定时任务方法上加上注释@Scheduled即可启动该定时任务。@Scheduled(cron=” * ?”)：按cron规则执行。 扩展以上采用定时到某个时刻。@Scheduled其他应用如下： @Scheduled(fixedRate=3000)：上一次开始执行时间点后3秒再次执行； @Scheduled(fixedDelay=3000)：上一次执行完毕时间点后3秒再次执行； @Scheduled(initialDelay=1000, fixedDelay=3000)：第一次延迟1秒执行，然后在上一次执行完毕时间点后3秒再次执行； 举例：12345//每3秒执行一次@Scheduled(fixedRate = 3000)public void timerRate() &#123; //TODO you want&#125;]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[客户端内嵌WebView与浏览器访问页面的安全机制]]></title>
    <url>%2F2017%2F06%2F24%2Fencryption_trans%2F</url>
    <content type="text"><![CDATA[近期新增代理商系统，游戏内加入webview以及从浏览器登录系统两种方式。作为服务端开发，与主管讨论之后，不同已有基于netty开发的多个服务器，服务端新增基于Spring-boot开发的服务器提供微服务。本文介绍安全机制设计与实现。 客户端内嵌WebView与服务器通信的加密方案安全验证采用token做密钥，摘要算法保证内容正确。摘要算法采用最常见的MD5即可。加密过程是服务端生成token，并把这个token发给客户端，客户端（这里包括WebView内页面）每次请求都附带stime以及token， 对这个字符串做计算形成摘要(sign)。客户端调用WebView之前，通过protobuffer协议获取token。123456789101112131415161718//请求访问代理页面的tokenmessage CGGetAgtTokenREQ&#123;&#125;message GCGetAgtTokenRES&#123; required int32 result = 1; required string token = 2;&#125;&lt;Protocol P_CG_GET_AGT_TOKEN_REQ = &quot;请求访问代理页面的token&quot; PROTOCOL_CLASS=&quot;com.kodgames.message.proto.game.GameProtoBuf.CGGetAgtTokenREQ&quot; /&gt;&lt;Protocol P_GC_GET_AGT_TOKEN_RES = &quot;响应token&quot; PROTOCOL_CLASS=&quot;com.kodgames.message.proto.game.GameProtoBuf.GCGetAgtTokenRES&quot; &gt;&lt;String name=&quot;GC_GET_AGT_TOKEN_SUCCESS&quot; isSuccess=&quot;true&quot;&gt;请求成功&lt;/String&gt;&lt;String name=&quot;GC_GET_AGT_TOKEN_FAILED&quot;&gt;请求失败&lt;/String&gt;&lt;/Protocol&gt; 此时客户端得到的token格式是:1&quot;GAME-&quot;+随机字符串 随机字符串生成规则采用:1UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;).substring(0,16).toUpperCase(); 客户端第一次拉起WebView，发送格式如下。页面直接将请求参数转发到服务端，服务端拿到完整url，在拦截器中用同样的算法做身份验证：1234567http://172.16.2.172:8091/agent/is_agent?id=5006872&amp;stime=1497680416778&amp;sign=35454B055CC325EA1AF2126E27707052其中token = &quot;GAME-XXXXXXXXX&quot;path = &quot;/agent/is_agent&quot;queryString = &quot;id=5006872&amp;stime=1497680416778&quot;sign = md5(queryString + &quot;&amp;token=&quot; + token) queryString是未加密之前的请求字符串，stime是客户端当前时间戳，服务端设置请求有效时间为一分钟，防止重放攻击。由于token只在第一次由服务端下发给客户端，后续无传输，所以在不泄露token的前提下，可有效保证客户端提交数据合法。 token发放机制，采用双token隔离安全性：123456789客户端初次请求服务端获取token，此时token=&quot;GAME-&quot;+随机字符串。客户端拉起webview访问页面，页面第一次向服务端提交请求，控制器判断token的类型，如果token类型是&quot;GAME-&quot;+随机字符串，则控制器重新发放页面内专用的token。此时token=&quot;AGENT-&quot;+随机字符串。webtoken是通过cookie的机制发送：Cookie cookie = new Cookie(&quot;token&quot;,token);httpServletResponse.addCookie(cookie);后续页面内请求均采用此token。退出页面时，把cookie置空，以免token泄露。 每次客户端访问时，会重新向服务端请求token，服务端更新token后发送给客户端。 浏览器网页登录与服务器通信的加密方案浏览器访问的用户认证不采用传统的sessionId，沿袭内嵌WebView与服务器通信的token认证，通过访问路径区分三种安全机制： 用户登录及修改密码采用临时token策略，用户进入页面即获取临时token及uuid，登录请求时携带uuid。服务端验证通过后，将临时token写入到用户正式表中，临时token表删除token。出现到一个问题，就是只有认证成功的用户，临时token才会被删除，其他情况不会被删除，导致临时token表即会越来越大，采用定时任务删除临时表token，即临时token表每天凌晨四点清理一次。涉及到密码相关的传输，密码本身要先加密一次。 用户登录后的安全保障同内嵌WebView与服务器通信的安全机制相同。 发送验证码、初次进入页面、用户确认等无安全威胁的请求，不走安全验证，服务端无需过滤。 举例说明，初次访问页面及登录请求格式如下：123http://172.16.2.163:8091/no_filter/first_comehttp://172.16.2.163:8091/agent/community_login?id=10003&amp;name=10001&amp;pwd=20CC88D2E204FFA768509D33FA882492&amp;type=1&amp;uuid=2f52ef92b73b43659045567ba29881c4&amp;stime=1498728038692&amp;sign=ECD622B701C2B90E33319E7E08A422A9]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端午出游]]></title>
    <url>%2F2017%2F05%2F29%2Fdragon_Boat_Festival%2F</url>
    <content type="text"><![CDATA[明十三陵:樱桃园-水库-蟒山-天池五月底的北京，已经进入炎热的状态，但今儿个天公作美，最高温也就27度，小风不断，十分舒爽。正值樱桃成熟季，于是昨天临时决定摘樱桃。这两张照片看起来跟偷樱桃似的。吃樱桃还是去现场摘的好，个大还甜，最后买了24斤带走，够吃一周的了。快艇师傅真是可以，开的飞快，翻了可咋整。蟒山的天池，是挺大的，空气也不错，就是得爬到山顶，山路只有一条，比较陡。]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见正则合法性校验]]></title>
    <url>%2F2017%2F05%2F24%2Fphone_id%2F</url>
    <content type="text"><![CDATA[正则表达式用于各个情形的数据校验，例如对请求参数的校验，客户端给服务器发送数据前，需初步对数据进行合法性校验；由于客户端数据不可信，服务器要对数据进行严格的合法性校验。本文记录的是常用的身份证及手机号等合法性正则校验。以Java编程为例。 手机号合法性校验这里合法性校验对象为中国大陆及港澳手机号。12345678910111213141516171819202122232425262728293031323334/** * 手机号合法性判断（大陆及港澳） */ public static boolean isPhoneLegal(String str) throws PatternSyntaxException &#123; return isMainLandPhoneLegal(str) || isHKPhoneLegal(str); &#125; /** * 大陆手机号码11位数，匹配格式：前三位固定格式+后8位任意数 * 此方法中前三位格式有： * 13+任意数 * 15+除4的任意数 * 18+除1和4的任意数 * 17+除9的任意数 * 147 */ public static boolean isMainLandPhoneLegal(String str) throws PatternSyntaxException &#123; String regExp = &quot;^((13[0-9])|(15[^4])|(18[0,2,3,4,5-9])|(17[0-8])|(147))\\d&#123;8&#125;$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); &#125; /** * 香港手机号码8位数，5|6|8|9开头+7位任意数 * 澳门手机号以6开头，可归到香港手机号判断中 * */ public static boolean isHKPhoneLegal(String str) throws PatternSyntaxException &#123; String regExp = &quot;^(5|6|8|9)\\d&#123;7&#125;$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); &#125; 以上手机号校验太严格，一般情况，不建议使用，大陆手机号可用以下正则简单校验即可:1String regExp = &quot;^1[34578]\\d&#123;9&#125;$&quot;; 身份证合法性校验以下是完整的测试函数，包括15位和18位身份证号合法性校验以及15位到18位身份证号的转换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;/** * 身份证合法性校验及15位身份证转为18位 * &lt;p&gt; * --15位身份证号码：第7、8位为出生年份(两位数)，第9、10位为出生月份，第11、12位代表出生日期，第15位代表性别，奇数为男，偶数为女。 * --18位身份证号码：第7、8、9、10位为出生年份(四位数)，第11、第12位为出生月份，第13、14位代表出生日期，第17位代表性别，奇数为男，偶数为女，最后一位为校验位。 */public class IdcardValidator &#123; /** * 省、直辖市代码表： * 11 : 北京 12 : 天津 13 : 河北 14 : 山西 15 : 内蒙古 * 21 : 辽宁 22 : 吉林 23 : 黑龙江 31 : 上海 32 : 江苏 * 33 : 浙江 34 : 安徽 35 : 福建 36 : 江西 37 : 山东 * 41 : 河南 42 : 湖北 43 : 湖南 44 : 广东 45 : 广西 46 : 海南 * 50 : 重庆 51 : 四川 52 : 贵州 53 : 云南 54 : 西藏 * 61 : 陕西 62 : 甘肃 63 : 青海 64 : 宁夏 65 : 新疆 * 71 : 台湾 81 : 香港 82 : 澳门 91 : 国外 */ private static String cityCode[] = &#123;&quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;31&quot;, &quot;32&quot;, &quot;33&quot;, &quot;34&quot;, &quot;35&quot;, &quot;36&quot;, &quot;37&quot;, &quot;41&quot;, &quot;42&quot;, &quot;43&quot;, &quot;44&quot;, &quot;45&quot;, &quot;46&quot;, &quot;50&quot;, &quot;51&quot;, &quot;52&quot;, &quot;53&quot;, &quot;54&quot;, &quot;61&quot;, &quot;62&quot;, &quot;63&quot;, &quot;64&quot;, &quot;65&quot;, &quot;71&quot;, &quot;81&quot;, &quot;82&quot;, &quot;91&quot;&#125;; /** * 每位加权因子 */ private static int power[] = &#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;; /** * 验证所有身份证的合法性 * * @param idcard 身份证 * @return 合法返回true，否则返回false */ public static boolean isValidatedAllIdcard(String idcard) &#123; if (idcard == null) &#123; return false; &#125; else if (idcard.length() == 15) &#123; return validate15IDCard(idcard); &#125; else if (idcard.length() == 18) &#123; return validate18Idcard(idcard); &#125; else &#123; return false; &#125; &#125; /** * 判断18位身份证的合法性 * 根据〖中华人民共和国国家标准GB11643-1999〗中有关公民身份号码的规定，公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。 * 排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。 * 顺序码: 表示在同一地址码所标识的区域范围内，对同年、同月、同 日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配 给女性。 * &lt;p&gt; * (1).前1、2位数字表示：所在省份的代码； * (2).第3、4位数字表示：所在城市的代码； * (3).第5、6位数字表示：所在区县的代码； * (4).第7~14位数字表示：出生年、月、日； * (5).第15、16位数字表示：所在地的派出所的代码； * (6).第17位数字表示性别：奇数表示男性，偶数表示女性； * (7).第18位数字是校检码：也有的说是个人信息码，一般是随计算机的随机产生，用来检验身份证的正确性。校检码可以是0~9的数字，有时也用x表示。 * &lt;p&gt; * 第十八位数字(校验码)的计算方法为： * (1).将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 * (2).将这17位数字和系数相乘的结果相加。 * (3).用加出来和除以11，看余数是多少 * (4).余数只可能有0 1 2 3 4 5 6 7 8 9 10这11个数字。其分别对应的最后一位身份证的号码为1 0 X 9 8 7 6 5 4 3 2 * (5).通过上面得知如果余数是2，就会在身份证的第18位数字上出现罗马数字的Ⅹ。如果余数是10，身份证的最后一位号码就是2。 * * @param idcard 18位身份证号 * @return 是否合法 */ public static boolean validate18Idcard(String idcard) &#123; if (idcard == null) &#123; return false; &#125; // 非18位为假 if (idcard.length() != 18) &#123; return false; &#125; // 获取前17位 String idcard17 = idcard.substring(0, 17); // 前17位全部为数字 if (!isDigital(idcard17)) &#123; return false; &#125; String provinceid = idcard.substring(0, 2); // 校验省份 if (!checkProvinceid(provinceid)) &#123; return false; &#125; // 校验出生日期 String birthday = idcard.substring(6, 14); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMdd&quot;); try &#123; Date birthDate = sdf.parse(birthday); String tmpDate = sdf.format(birthDate); if (!tmpDate.equals(birthday)) &#123;// 出生年月日不正确 return false; &#125; &#125; catch (ParseException e1) &#123; return false; &#125; // 获取第18位 String idcard18Code = idcard.substring(17, 18); char c[] = idcard17.toCharArray(); int bit[] = converCharToInt(c); int sum17 = 0; sum17 = getPowerSum(bit); // 将和值与11取模得到余数进行校验码判断 String checkCode = getCheckCodeBySum(sum17); if (null == checkCode) &#123; return false; &#125; // 将身份证的第18位与算出来的校码进行匹配，不相等就为假 if (!idcard18Code.equalsIgnoreCase(checkCode)) &#123; return false; &#125; return true; &#125; /** * 校验15位身份证 * 只校验省份和出生年月日 * * @param idcard * @return */ public static boolean validate15IDCard(String idcard) &#123; if (idcard == null) &#123; return false; &#125; // 非15位为假 if (idcard.length() != 15) &#123; return false; &#125; // 15全部为数字 if (!isDigital(idcard)) &#123; return false; &#125; String provinceid = idcard.substring(0, 2); // 校验省份 if (!checkProvinceid(provinceid)) &#123; return false; &#125; String birthday = idcard.substring(6, 12); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyMMdd&quot;); try &#123; Date birthDate = sdf.parse(birthday); String tmpDate = sdf.format(birthDate); if (!tmpDate.equals(birthday)) &#123;// 身份证日期错误 return false; &#125; &#125; catch (ParseException e1) &#123; return false; &#125; return true; &#125; /** * 将15位的身份证转成18位身份证 * * @param idcard * @return */ public static String convertIdcarBy15bit(String idcard) &#123; if (idcard == null) &#123; return null; &#125; // 非15位身份证 if (idcard.length() != 15) &#123; return null; &#125; // 15全部为数字 if (!isDigital(idcard)) &#123; return null; &#125; String provinceid = idcard.substring(0, 2); // 校验省份 if (!checkProvinceid(provinceid)) &#123; return null; &#125; String birthday = idcard.substring(6, 12); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyMMdd&quot;); Date birthdate = null; try &#123; birthdate = sdf.parse(birthday); String tmpDate = sdf.format(birthdate); if (!tmpDate.equals(birthday)) &#123;// 身份证日期错误 return null; &#125; &#125; catch (ParseException e1) &#123; return null; &#125; Calendar cday = Calendar.getInstance(); cday.setTime(birthdate); String year = String.valueOf(cday.get(Calendar.YEAR)); String idcard17 = idcard.substring(0, 6) + year + idcard.substring(8); char c[] = idcard17.toCharArray(); String checkCode = &quot;&quot;; // 将字符数组转为整型数组 int bit[] = converCharToInt(c); int sum17 = 0; sum17 = getPowerSum(bit); // 获取和值与11取模得到余数进行校验码 checkCode = getCheckCodeBySum(sum17); // 获取不到校验位 if (null == checkCode) &#123; return null; &#125; // 将前17位与第18位校验码拼接 idcard17 += checkCode; return idcard17; &#125; /** * 校验省份 * * @param provinceid * @return 合法返回TRUE，否则返回FALSE */ private static boolean checkProvinceid(String provinceid) &#123; for (String id : cityCode) &#123; if (id.equals(provinceid)) &#123; return true; &#125; &#125; return false; &#125; /** * 数字验证 * * @param str * @return */ private static boolean isDigital(String str) &#123; return str.matches(&quot;^[0-9]*$&quot;); &#125; /** * 将身份证的每位和对应位的加权因子相乘之后，再得到和值 * * @param bit * @return */ private static int getPowerSum(int[] bit) &#123; int sum = 0; if (power.length != bit.length) &#123; return sum; &#125; for (int i = 0; i &lt; bit.length; i++) &#123; for (int j = 0; j &lt; power.length; j++) &#123; if (i == j) &#123; sum = sum + bit[i] * power[j]; &#125; &#125; &#125; return sum; &#125; /** * 将和值与11取模得到余数进行校验码判断 * * @param sum17 * @return 校验位 */ private static String getCheckCodeBySum(int sum17) &#123; String checkCode = null; switch (sum17 % 11) &#123; case 10: checkCode = &quot;2&quot;; break; case 9: checkCode = &quot;3&quot;; break; case 8: checkCode = &quot;4&quot;; break; case 7: checkCode = &quot;5&quot;; break; case 6: checkCode = &quot;6&quot;; break; case 5: checkCode = &quot;7&quot;; break; case 4: checkCode = &quot;8&quot;; break; case 3: checkCode = &quot;9&quot;; break; case 2: checkCode = &quot;x&quot;; break; case 1: checkCode = &quot;0&quot;; break; case 0: checkCode = &quot;1&quot;; break; &#125; return checkCode; &#125; /** * 将字符数组转为整型数组 * * @param c * @return * @throws NumberFormatException */ private static int[] converCharToInt(char[] c) throws NumberFormatException &#123; int[] a = new int[c.length]; int k = 0; for (char temp : c) &#123; a[k++] = Integer.parseInt(String.valueOf(temp)); &#125; return a; &#125; public static void main(String[] args) throws Exception &#123; String idcard15 = &quot;130321860311519&quot;; String idcard18 = &quot;210102198617083732&quot;;// // 15位身份证 System.out.println(isValidatedAllIdcard(idcard15)); // 18位身份证 System.out.println(isValidatedAllIdcard(idcard18)); // 15位身份证转18位身份证 System.out.println(convertIdcarBy15bit(idcard15)); &#125;&#125; 银行卡号合法性校验123456789101112131415161718192021222324252627282930313233343536373839/** * 校验银行卡卡号 * @param cardId * @return */public static boolean checkBankCard(String cardId) &#123; if(cardId.length() != 16 &amp;&amp; cardId.length() != 19)&#123; return false; &#125; char bit = getBankCardCheckCode(cardId.substring(0, cardId.length() - 1)); if(bit == &apos;N&apos;)&#123; return false; &#125; return cardId.charAt(cardId.length() - 1) == bit;&#125;/** * 从不含校验位的银行卡卡号采用 Luhm 校验算法获得校验位 * @param nonCheckCodeCardId * @return */public static char getBankCardCheckCode(String nonCheckCodeCardId)&#123; if(nonCheckCodeCardId == null || nonCheckCodeCardId.trim().length() == 0 || !nonCheckCodeCardId.matches(&quot;\\d+&quot;)) &#123; //如果传的不是数据返回N return &apos;N&apos;; &#125; char[] chs = nonCheckCodeCardId.trim().toCharArray(); int luhmSum = 0; for(int i = chs.length - 1, j = 0; i &gt;= 0; i--, j++) &#123; int k = chs[i] - &apos;0&apos;; if(j % 2 == 0) &#123; k *= 2; k = k / 10 + k % 10; &#125; luhmSum += k; &#125; return (luhmSum % 10 == 0) ? &apos;0&apos; : (char)((10 - luhmSum % 10) + &apos;0&apos;);&#125; 密码合法性校验（6-10位字母数字组合为例）123456public static boolean isNewPwdIllegal(String str) throws PatternSyntaxException &#123; String regExp = &quot;^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,10&#125;$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches();&#125; 时间格式yyyy-MM-dd hh:mm:ss123456public static boolean isLegalTime(String str)&#123; String regExp = &quot;^(((([0-9]&#123;3&#125;[1-9]|[0-9]&#123;2&#125;[1-9][0-9]|[0-9][1-9][0-9]&#123;2&#125;|[1-9][0-9]&#123;3&#125;)-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]&#123;2&#125;)(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29)) (20|21|22|23|[0-1][0-9]):[0-5][0-9]:[0-5][0-9])$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); &#125; 邮箱格式123456public static boolean isMailLegal(String str)&#123; String regExp = &quot;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); &#125; Ipv4地址123456public static boolean isIpv4(String str)&#123; String regExp = &quot;([1-9]|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]))&#123;3&#125;&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); &#125; Boolean类型的字符串形式123456public static boolean isBoolean(String str)&#123; String regExp = &quot;^(true)|(false)$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str.toLowerCase()); return m.matches(); &#125; unix时间戳，毫秒级，到2030年123456public static boolean isLegalTimestamp(String str) &#123; String regExp = &quot;^1[5-9]\\d&#123;11&#125;$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches();&#125; qq号及微信号Regex12qq号：^[1-9][0-9]&#123;4,10&#125;$微信号：^[a-zA-Z][-_a-zA-Z0-9]&#123;5,19&#125;$ 微信号规则参考：http://kf.qq.com/touch/faq/120813euEJVf141212Vfi6fA.html 正则表达式使用场景很多，不复杂的现用现写即可。网上有许多常用正则表达式总结，用时参考。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Limax ZDB简单介绍及死锁分析]]></title>
    <url>%2F2017%2F05%2F22%2Flimax_zdb%2F</url>
    <content type="text"><![CDATA[背景limax是比较小众的应用服务器框架，zdb是limax采用的数据存储方式。zdb采用k-v存储，没有事务的概念，自带锁（加锁和解锁同操作封装在一起，对外隐藏），编程较为简单。项目前期使用zdb进行数据存储，随着项目规模的扩大，暴露出一些问题。每个服务器都有一个zdb.xml文件，基于该文件，ant构建生成的table和xbean也只有当前服务器可以读取。为保证数据一致性，zdb使用方式若未严格注意，导致数据分散在不同职能的服务器上，当某个功能需要的数据需要从不同的服务器上读取时，这就很尴尬了，数据读取繁琐，服务器之间通信协议的繁琐导致编程的繁琐。现在正在逐步废弃zdb，采用主流的mysql+redis存储。 ZDBzdb定义表时，主键无法定义键名，只需定义主键类型。以简单的手机绑定送钻功能为例,zdb设计如下，mobile_id_table为表名，string为主键类型，当前表主键为账户ID，value为记录类，MobileIdBean定义记录包括的字段。 12345678&lt;table name=&quot;mobile_id_table&quot; key=&quot;string&quot; value=&quot;MobileIdBean&quot;/&gt;&lt;xbean name=&quot;MobileIdBean&quot;&gt;&lt;variable name=&quot;accountId&quot; type=&quot;int&quot;/&gt;&lt;!-- 账号ID --&gt; &lt;variable name=&quot;bindTime&quot; type=&quot;long&quot;/&gt;&lt;!-- 绑定时间 --&gt; &lt;variable name=&quot;status&quot; type=&quot;string&quot;/&gt;&lt;!-- 验证状态 --&gt; &lt;variable name=&quot;code&quot; type=&quot;string&quot;/&gt;&lt;!-- 验证码 --&gt; &lt;variable name=&quot;codeTime&quot; type=&quot;long&quot;/&gt;&lt;!-- 验证码发放时间 --&gt;&lt;/xbean&gt; 需求中除了通过手机号查绑定时间和账户ID，还有通过账号ID查绑定时间和手机号。由于zdb的局限性，导致第二张表的产生。zdb查特定数据只能通过主键，所以这里采取双向表的方式，但是有数据冗余的问题，都存储了绑定时间。但是查数据快，无论何种方式查，都仅需查一张表。 123456&lt;table name=&quot;id_mobile_table&quot; key=&quot;int&quot; value=&quot;IdMobileBean&quot;/&gt;&lt;xbean name=&quot;IdMobileBean&quot;&gt;&lt;variable name=&quot;accountMobile&quot; type=&quot;string&quot;/&gt;&lt;!-- 账号手机号 --&gt;&lt;variable name=&quot;bindTime&quot; type=&quot;long&quot;/&gt;&lt;!-- 绑定时间 --&gt;&lt;variable name=&quot;bindAward&quot; type=&quot;int&quot;/&gt;&lt;!-- 绑定所得奖励，历史记录 --&gt;&lt;/xbean&gt; 为解决上述数据冗余的问题，可采用如下方式： 1234&lt;table name=&quot;id_mobile_table&quot; key=&quot;int&quot; value=&quot;IdMobileBean&quot;/&gt;&lt;xbean name=&quot;IdMobileBean&quot;&gt; &lt;variable name=&quot;accountMobile&quot; type=&quot;string&quot;/&gt;&lt;!-- 账号手机号 --&gt;&lt;/xbean&gt; 通过手机查，直接查第一张表。通过账号ID查，查第二张表，拿到手机号后再查第一张表。通过账号ID查数据就变得比较繁琐，需要读两张表。zdb定义定义完成后，cmd到对应路径下执行ant，即生成相应的table类及xbean类。zdb遍历数据效率比较低。只有walk一种方式: 1table.mobile_id_table.get().walk((key, value) -&gt; &#123;return true;&#125;); 操作是从硬盘中读取数据到内存，效率比较低。而且会导致数据不一致的情况，增删改数据后，可能出现内存数据尚未落地到硬盘，get().walk获取的数据是从硬盘直接获得的，获取到的是未执行增删改前的错误数据。 1table.Channel_version_table.get().getCache().walk((key, value) -&gt; &#123; &#125;); 操作是从内存中读取数据，相对于第一种，效率肯定高。这种操作只会读取内存的数据，不会读取硬盘的数据，会导致数据读取不完全。采取的解决方法是起服时将所需表的数据get().walk到内存中，后续数据都是操作内存，除了提升效率外，不会导致数据不一致或数据不完全的情况。zdb读取数据时，能不使用walk遍历就不适用walk遍历数据，可采用配置文件或者哈希表存储主键（适用于记录较少的情况），然后逐一select。select操作是先从内存中读数据，若内存中无数据，再从硬盘中读取数据。 死锁还未弃用zdb时，由于编程的错误导致死锁，这里介绍一下zdb死锁的情况及注意事项。 1234567MobileIdBean mobileIdBean = table.Mobile_id_table.select(phoneNumber);if (mobileIdBean == null)&#123; mobileIdBean = table.Mobile_id_table.insert(phoneNumber); mobileIdBean.setAccountId(roleId); mobileIdBean.setCodeTime(0);&#125; 并发执行select（线程获取读锁）同一个phoneNumber时，会出现多线程进入到if里，执行最快的线程insert（升级为写锁），成功，后续setAccountId等操作正常进行。而其余线程insert失败，返回null，操作出错。应该将select更改为update,初始就获取写锁，并发的后续线程就只能等待前一线程结束，不会出现多个线程同时进入到if的情况。 1234567MobileIdBean mobileIdBean = table.Mobile_id_table.update(phoneNumber);if (mobileIdBean == null)&#123; mobileIdBean = table.Mobile_id_table.insert(phoneNumber); mobileIdBean.setAccountId(roleId); mobileIdBean.setCodeTime(0);&#125; 涉及到后续数据更改的情况，不要使用select，select获取的读锁，其他操作（insert/delete/update）获取的是写锁。 题外话，关于缓存针对主流的mysql+redis存储。由于直接对mysql读写数据效率低，引入缓存可解决效率问题。引入缓存可能会出现与数据库数据不一致的情况，避免这种情况的发生，读写数据时可采取如下策略保证缓存与数据库数据保持一致。 读数据保持一致先读取缓存，若不存在则从DB中读取，并将结果写入到缓存中；下次数据读取时便可以直接从缓存中获取数据。 写数据保持一致（淘汰策略）数据的修改是直接失效缓存数据，再修改DB内容，避免DB修改成功，但由于网络或者其他问题导致缓存数据没有清理，造成了脏数据。 淘汰策略简单容易编程， 但是性能不好，先写入 mysql的时候有可能耗时过长。 可考虑双写策略：不但写入Redis，还会写入 Mysql。双写策略性在Redis上写入性能很好，此时数据立刻可用，在Mysql上可能会出现大量并发写入阻塞，一般会采用高可靠消息队列加强Mysql的写入。 还有一种版本策略，每次写入Redis，做增量写入，不覆盖原有数据，将数据版本增加，采用消息队列延迟写入 Mysql。版本策略编程较为复杂。 如果数据逻辑上是读多写少，采用淘汰策略足够。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL免安装版配置]]></title>
    <url>%2F2017%2F05%2F16%2Fmysql%2F</url>
    <content type="text"><![CDATA[如果要使用Mysql，直接下载安装WAMP或者LAMP即可。若对免安装Mysql有兴趣，可参考本文。最近重装系统后，整了一个免安装版的Mysql，配置步骤记录如下。Windows64下通用，配置不受Mysql版本号的影响。我是在Win7配置，版本号为5.7.18。下载地址 解压MySQL压缩包将下载的MySQL压缩包解压到自定义目录下，我的解压目录是: G:\mysql\mysql-5.7.18-winx64 新建my.ini， 复制下面的配置信息到 my.ini 保存1234567891011121314151617[client]port=3306default-character-set=utf8[mysqld]port=3306character_set_server=utf8#解压目录basedir=G:\mysql\mysql-5.7.18-winx64#解压目录下data目录datadir=G:\mysql\mysql-5.7.18-winx64\datasql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[WinMySQLAdmin]G:\mysql\mysql-5.7.18-winx64\bin\mysqld.exe 添加环境变量1.系统变量下新建变量，变量名为：MYSQL_HOME，变量值为G:\mysql\mysql-5.7.18-winx642.编辑系统变量的Path，添加变量值;%MYSQL_HOME%\bin 生成data文件夹1.从控制台进入到MySQL解压目录下的 bin 目录下（直接在目录下按住shift，点击鼠标右键可看到“在此处打开命令行窗口”）2.输入服务安装命令： mysqld --console mysqld --initialize mysqld install 安装成功后会提示服务安装成功：Service successfully installed。之所以执行这几步，是因为在解压目录中没有data文件夹，需要用这几个命令产生data文件夹。注：移除服务命令为：mysqld remove若执行mysqld install后，系统提示Install/Remove of the Service Denied!，则用管理员身份运行cmd即可 启动MySQL服务方法一：启动服务命令为：net start mysql方法二： 打开管理工具 服务，找到MySQL服务。通过右键选择启动或者直接点击左边的启动来启动服务 修改 root 账号的密码当成功进入开启服务以后，cmd下执行 mysql -u root -p 回车，输入密码，出现： ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: NO) 关闭服务 net stop MySQL 用安全模式打开 mysqld --skip-grant-tables 此时光标会一直闪。注意，不要关闭当前窗口，打开另一个命令行窗口。 和前面一样的操作，在bin目录下打开cmd，登录 mysql -u root -p 密码为空,直接回车即可进入。执行 use mysql; update user set authentication_string=password(&quot;123456&quot;) where user=&quot;root&quot;; flush privileges; 登录刚开始启动失败，是因为mysqld进程还开着呢，kill掉重新登录即可。注：若安装成功，进入mysql，不管执行什么命令都提示：You must reset your password using ALTER USER statement before executing this statement.则执行以下三步：12345step 1: SET PASSWORD = PASSWORD(&apos;your new password&apos;);step 2: ALTER USER &apos;root&apos;@&apos;localhost&apos; PASSWORD EXPIRE NEVER;step 3: flush privileges;]]></content>
      <tags>
        <tag>技术</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效洗牌算法介绍]]></title>
    <url>%2F2017%2F04%2F14%2Fshuffle_introduce%2F</url>
    <content type="text"><![CDATA[最近写了一个梭哈牌戏Demo，简单介绍用到的洗牌算法。123456789101112131415161718public void shuffle()&#123; // 随机位数索引 int tmpIndex; // 临时存储数组当前值 Card tmpCard; for (int i = 0; i &lt; CardDeck.DECK_SIZE; i++) &#123; tmpIndex = (int)(Math.random() * CardDeck.DECK_SIZE); if (tmpIndex != i) &#123; tmpCard = cards[tmpIndex]; cards[tmpIndex] = cards[i]; cards[i] = tmpCard; &#125; &#125; return;&#125; 思想：从数组第一位开始，随机random一个数字，第一位和随机出的那位交换；然后依次遍历这个过程到最后一张牌。时间复杂度O(n)，空间复杂度O(1)。优点：与抽牌算法（随机抽牌放到新数组，直到抽完为止）相比，当前洗牌算法随机性更强，已随机的位数仍会与后面随机的数位交换；无需开辟新数组，空间复杂度降低。另外，Demo与传统梭哈相比，加入五张鬼牌，难度升级。牌型判断及简单机器博弈算法还是有点难度的。感兴趣可看下Demo：Github链接]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏开发历程记录-H5]]></title>
    <url>%2F2017%2F03%2F26%2FH5_record%2F</url>
    <content type="text"><![CDATA[背景H5游戏前端开发有将近一年经验，大部分项目都是单兵作战。主要使用引擎和语言为Egret(TypeScipt)，Construct2(JavaScript)。前端完全独立开发的上线游戏有三款：Survival（活下去），砰砰兔，IO游戏炸弹人。现在转向游戏服务端开发，开发语言目前以Java为主，项目包括App及H5，棋牌类为主。这里是对之前的H5开发项目进行阶段性的总结。 正式项目Survival：开发的第一款H5手游，负责后半段的前后端开发。Egret GUI项目,后端使用php和mysql，文字类游戏,视频链接。 个人服务器demo链接地址 ，demo太简陋，感兴趣直接到qq空间玩一下。砰砰兔：简单的Egret EUI项目，个人服务器demo链接地址。IO游戏炸弹人：以泡泡堂为原型，国内海外两版，周期三个月。使用网易pomelo框架，前端主要是业务逻辑和插件的开发，后端由一个小伙伴负责，主要使用node。 练习项目时钟大战：简单的Egret EUI 项目，链接地址。飞机大战（链接地址）及flappybird（链接地址）: Construct2小项目,美术素材就是从网上随便找的。Construct2中引入Spriter插件进行骨骼动画测试，测试效果链接,相比帧动画，性能和效果流畅度提升，但是对象数量飙升。若项目对象数量少，如对打或者闯关游戏，可选择使用。]]></content>
      <tags>
        <tag>Html5</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github 标记图标的更改]]></title>
    <url>%2F2017%2F03%2F12%2FgitIgnore%2F</url>
    <content type="text"><![CDATA[github上传新项目时，发现没有分类图标（图标错误也是这么改），这里将添加过程记录下来。根目录下新建.gitattributes文件，将以下内容复制保存。123*.js linguist-language=Java*.css linguist-language=Java*.html linguist-language=Java 该文件将html、css、js（想关联的文件）文件关联为Java(目标类型)。此时，github将此项目识别为Java项目。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Construct2使用心得]]></title>
    <url>%2F2017%2F03%2F03%2Fconstruct2_conclusion%2F</url>
    <content type="text"><![CDATA[Construct2从接触到使用已有半年时间，优点就是上手容易，开发快，但只适合小型2D-H5游戏且是闭源，很适合懂技术的策划使用，对程序猿来讲，玩玩即可。同大多数H5游戏引擎相同，也是一次开发，导出多平台包。引擎本身只提供基础功能，插件的使用及开发是Construct2核心之一。官方论坛上有各种需要的插件，C2插件大神Rex贡献尤为突出。 前端架构建议 将全局变量统一放到一个事件表中，我习惯命名为Global，统一管理全局变量。 不能过分使用全局变量，根据变量的作用域分类，只跟某个对象有关放到对象的局部变量中；如果变量只在当前layout有效，可以考虑放到对象的局部变量中，或者当前布局所有事件放到一个大组里，变量声明在当前组内。 资源管理上，在Object types下建立子文件夹；对象动画较多或者打算将多个对象合并到一个对象上（也建议这么做）时，对象动画位置建立子文件夹。 对于行为完全相同的对象，要放到同一个family中。 根据功能分类，合理使用Group。 多使用Function，如果当前布局事件过多（如超过200条），将所有函数放到一个事件表中，然后在主事件表中引入。 如果不使用 C2默认的loader布局，将use loader layout选为yes , 将first layout选择个人定义的加载布局，但是如果个人设置的加载布局稍微有些复杂，C2的默认的loader布局依然会显示，此时将发布包的logo替换即可。 若一个物体如boss由多个对象组成，将多个对象放到一个container中；希望某些对象同时创建或者删除，也考虑使用container，很好用。使用container时，选择container的某个对象，此时可直接操作该container的其他对象，选择当前对象的过程也是选择当前整个container。 对象尽量少，若多个对象有不同动画但是功能完全相同，统一成一个对象（类）上，通过不同动画控制显示或者通过同一动画的不同帧来控制。 spriter在construct2中支持良好，很多情况下都可以选择骨骼动画而不是帧动画，尤其是对象数量较少的情况下。 性能优化及使用小结 关闭不需要碰撞对象的碰撞（默认都开启），提高前端性能。 C2若使用全套物理引擎即对象引入physics属性，对于pc端，为保证性能，物理对象不能超过100，移动端不能超过40。物理对象只能与物理对象交互。 若浏览器不支持webgl，运行期间会出现闪退，禁用webgl即可，此时为canvas。 将要声音的格式转为wav,引入的过程，引擎会自动转为ogg和m4a两种格式。 Form control下的对象如Button处于游戏视图最上层。可直接更改css更改样式。 C2可打包成多种类型，如H5,Android,Nw.js等。打包成app，需之后使用phonegap build等工具构建app。 talkingData等接入，需在index.html文件中引入外源文件。 踩过的坑 set size 不能和 set scale连用，相当于同一种操作，都是在原始对象尺寸上做更改，后者会覆盖前者。 设置子弹属性，应先设置速度，再设置角度，因为如果设置角度，速度若为0，不生效。 C2数组push元素，之后clear,不会生效，push的元素依然在。 隐形Button不可用，设置成visible后，touchEnabled也被禁用。 invisible的对象仍可touch，如果想实现打开某个页面后，下面图层的对象不可touch，可采取给不可touch的对象加入控制变量及cooldown属性(冷却时间设为0.1秒)，当页面打开后，控制变量更改，cooldown request，当cooldown finish时，控制变量重置。 C2中类型有限，而且调用calljs将text类型的变量作为参数时，应如下”output(“””&amp;userID&amp;”””)”，注意userID两侧的引号，若无引号”output(“&amp;userID&amp;”)”，会导致获取到的userID不是字符串，而是没有引号的字符串，很奇怪。 callJs不可在on start of layout使用。 涉及到回调处理时，均需封装成C2插件，在插件内执行。如superSDK接口调用。 C2中无法实现console.log(),只能设置Text值进行输出，可使用callJS, js中输出。执行某个操作但是需在回调中处理逻辑，需封装成插件。 C2插件大神rexRainbow说，c2没有什么是一个wait不能解决的，如果有，那就两个。合理使用wait0，填引擎自身的坑。 曾使用及开发的插件behaviors插件 设置对象椭圆运动—cicle 实现通过名字创建特定对象，需behavior插件rex_bnickname与plugin插件rex_nickname一同引入 冷却时间，倒计时使用，需behavior插件rex_cooldown与plugin插件rex_timeline一同引入 rex_moveto，设置对象移动到某个位置，常用做爆炸类特效 rex_pin2imagepoint，官方只能将对象pin到另一个对象imagePoint=0的位置，只有一个pin点，使用此行为可以pin到某个对象的不同imagePoint上 liteTween,缓动动画effects插件 浮雕颜色anaglyphcolor 背景模糊特效basicBlurplugins插件 JSON_for_construct2-master—JSON数据存储与使用 callJS—调用外部js scml是C2的spriter骨骼动画插件 spritefont+，第三方字体插件；C2SpriteFont制作工具,C2字体制作工具，配合C2自带的spritefont使用 rex_gfsm为FSM插件，有限状态机 最近开发的IO游戏炸弹人，前后端通信使用网易的Pomelo。C2的数据类型很少，数据处理这块做的不好，于是将pomelo及superSDK封装为C2插件，游戏客户端与服务器的数据处理及通信等即在这两个插件中完成。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>JavaScript</tag>
        <tag>Construct2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下使用Hexo+Github搭建个人博客]]></title>
    <url>%2F2017%2F01%2F01%2Fhexo_gitpages%2F</url>
    <content type="text"><![CDATA[Hexo介绍静态博客生成器，根据给定的主题，负责把写好的 Markdown 文章转换成一堆 HTML + CSS + Javascript 页面。另外，Hexo 还有把生成好的站点上传到 Github Pages 的功能。 背景记录个人学习和生活，作为程序猿，搭建个人博客是个不错的选择。但只是个博客，购买云服务器有些不值当，服务器稍微好些的配置就得上千。之前好友买过国外的服务器，hosts不加域名解析经常访问不到，更悲催的是，.com域名还被污染了，吓得我抱紧自己，决定用免费的gitPages吧。搭建的时候看过一些教程，还是遇到了一些问题（其实直接看hexo官网就ok的）。我在搭建时，使用的是Win10系统，以下搭建步骤是支持所有Wins系统的。OS系统下搭建与Wins不同，以hexo官网为准，可参考本文 搭建步骤 1.首先安装git及node，申请github账号并将ssh key配置完成。 2.cmd下输入powershell，进入cmd超级加强版（这一步可忽略，对搭建博客无影响）。 3.npm的任何操作都无法使用时，卸载node重装，并删除 C:\Users\Administrator\AppData\Roaming\npm C:\Users\Administrator\AppData\Roaming\npm-cache文件夹 4.在安装npm时，可能根据某个教程设置了例如： npm config set prefix &quot;C:\Program Files\nodejs\node_global&quot; npm config set cache &quot;C:\Program Files\nodejs\node_cache&quot; 设置出错可能就导致npm无法使用，此时需恢复到默认。npm config恢复到默认只需删除C:\Users\Administrator.npmrc文件。如果.npmrc不在这个目录下，就全局搜一下啦。当我遇到第3和第4步，我的内心是这样的 5.安装hexo，执行命令 npm install hexo-cli -g 6.安装hexo生成页面部署到github的组件，执行 npm install hexo-deployer-git --save 7.创建放置博客文件的文件夹 hexo init blog 8.进入到新创建的博客项目中 cd blog 9.安装依赖包 npm install 10.生成博客页面 hexo generate 11.本地起服 hexo server 浏览器访问 http://localhost:4000/ 可以预览博客样式 12.github创建仓库：仓库名必须为youname.github.io, 例如我的仓库名为monkeydbean.github.io 13.在本地博客目录下，打开git bash,以我的为例，执行 git init git add remote origin https://github.com/MonkeyDBean/MonkeyDBean.github.io.git 14.配置文件_config.yml更改如下1234deploy: type: git repo: https://github.com/MonkeyDBean/MonkeyDBean.github.io.git branch: master 注：YAML语法，字典是由简单的键: 值的形式组成(冒号后面必须是一个空格),如type:+&amp;nbsp+git 15.部署到github，执行 hexo deploy 若提交不上去，检查语法；没问题的话重新执行 npm install hexo-deployer-git --save hexo deploy 执行到这一步，以上步骤没问题的话，浏览器输入 https://monkeydbean.github.io 可访问个人博客，此时只有HelloWorld单页面。 16.每次部署，可按以下步骤进行： hexo clean hexo generate hexo deploy 17.让博客炫起来，最简单的，得有个主题，搜索输入hexo 知乎，选一个主题开始使用吧，主题的使用方法在相应主题的github上有详细介绍。包括头像、站点图标等基础设置及第三方接入等高级设置。 18.绑定域名：首先得有一个域名，域名服务商有很多，我这里用的万网，阿里云域名服务用的就是万网。注册完成后，搜索心仪域名是否被使用，未被使用即可购买，.cn域名比较便宜，第一年29元，无需购买扩展服务。域名购买完成后，添加cname解析如下：同时，在博客public目录下新建CNAME文件：执行步骤16，浏览器输入monkeyben.cn即可访问个人博客。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Http中GET与POST的区别]]></title>
    <url>%2F2016%2F10%2F29%2Fget_post%2F</url>
    <content type="text"><![CDATA[最近看了几篇介绍GET与POST的文章，讲的很有意思，在这里引用总结一下。 区别Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE，分别对应着资源的查，改，增，删。 GET和POST是HTTP请求的两种基本方法，GET一般用于获取资源信息，而POST一般用于更新资源信息。 GET请求在URL中传送的参数是有长度限制的，最多只能是1024字节，理论上POST木有限制，可传较大量的数据。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 GET在浏览器回退时是无害的，而POST会再次提交请求。 …………灯，灯灯灯灯从表面看，GET与POST的区别那么多，实际上呢？让我们扒下GET和POST的外衣，坦诚相见吧! 定义根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。根据HTTP规范，POST表示可能修改变服务器上的资源的请求。请注意，这几个字“根据HTTP规范”。HTTP是什么?HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。GET和POST又是什么?HTTP协议中的两种发送请求的方法。 比喻在万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到。 本质GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包;POST产生两个TCP数据包。长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么?1.GET与POST都有自己的语义，不能随便混用。2.据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。3.并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egret简略总结]]></title>
    <url>%2F2016%2F09%2F02%2Fegret_conclusion%2F</url>
    <content type="text"><![CDATA[Egret使用已有大半年，相比其他H5引擎，Egret的优势是官方文档齐全，配套工具完善，但性能不是很突出。 曾使用官方提供的配套工具 界面排布及属性预设—Egret Wing 碎图压缩合成大图及MovieClip动画素材处理—TextureMerger 资源管理—ResDepot chrome下调试插件—Egret Inspector 粒子效果制作—EgretFeather 当然，代码编写还是要用WebStorm及Sublime。以及开发中常用到的小小工具：在线图片压缩—TinyPng.com,合图分割—pngSplit，在线Json转换—bejson，二维码生成器cli.im等等。 调试参数说明及MovieClip index.html中，data-entry-class = “Main”,进入游戏访问的第一个Ts文件，入口类；data-orientation=”auto”,旋转方向设置；data-frame-rate = “60”,游戏帧率设置，可更改，建议为60的约数，正式项目基本设置为60，测试时更改。data-show-fps=”false”,默认为false,开启后可看到实时帧率，测试使用；data-show-log = “false”,默认为false,开启后，代码中egret.log()中的内容即显示在屏幕中，测试使用。 开启fps后的参数说明。FPS为帧率；Draw为每帧draw方法调用的平均次数，脏矩阵占舞台的百分比；Cost为每帧舞台所有事件处理及矩阵运算耗时，绘制显示对象耗时（单位为ms）。 MovieClip举例123456789101112131415161718192021222324252627282930class Bomb extends egret.Sprite&#123; private mcf:egret.MovieClipDataFactory; private mc:egret.MovieClip; public constructor() &#123; super(); this.init(); &#125; public init(str1:string,str2:string,number:number):void &#123; var data = RES.getRes(str1); var tex = RES.getRes(str2); this.mcf = new egret.MovieClipDataFactory(data, tex); this.mc = new egret.MovieClip(); this.mc.movieClipData = this.mcf.generateMovieClipData(); this.mc.play(number); //playTimes:number — 播放次数。 参数为整数，可选参数，&gt;=1：设定播放次数，&lt;0：循环播放，默认值 0：不改变播 放次数(MovieClip初始播放次数设置为1)， this.addChild(this.mc); this.mc.addEventListener(egret.Event.COMPLETE, this.removeBomb, this); &#125; //轰炸完毕 private removeBomb(evt:egret.Event):void &#123; if(this.parent!=null) &#123; this.parent.removeChild(this); &#125; &#125;&#125; 性能优化 Audio 如果需求中需要同时播放多个音频，则使用WebAudio。X5浏览器内核WebAudio可支持多音频。Egret3.1.4之后，index.html文件中，egret.runEgret({renderMode:”webgl”,audioType:0}); 默认的渲染模式为Canvas,之前微信平台上的游戏使用的均为Canvas。音频类型中，默认为0，IOS7以上表示WebAudio；1表示QQ Audio，项目若在腾讯平台上线如QQ空间中的玩吧，则使用QQ Audio，腾讯解析音频有自己的一套方案；2表示强制使用WebAudio;3表示使用浏览器自带的Audio，不推荐。 当多个音频轮询播放播放的时候，如ababa，如果打开网络侦听，有可能发现播放一次向服务器请求一次，原因是不同浏览器内核对音频实现方式不一样。解决方案是：将轮询播放的多个音频拼成一个音频，通过时间段控制播放。 由于浏览器的安全限制，加载完成可能无法自动播放背景音乐，这种情况将背景音乐设置成点击播放的形式，如加载完成后，弹出按钮，玩家点击选择是否播放背景音乐。主流H5游戏均是采用这种方式。 Text TextField中使用cacheAsBitmap，可以减少重绘次数。原因是TextField是文本，浏览器渲染通过CPU的计算，对图片渲染速度快，对文本渲染速度慢。 TextField减少对于描边（stroke）的使用，用图片代替。 输入文本框尽量出现在软键盘的上面，手机部分浏览器中，如果输入文本框太靠下，弹出的软键盘会遮挡住输入文本框。 Image 单张图（包括SpriteSheet）的大小不要超过1024*1024,浏览器对图片大小限制会对超过的该尺寸大小的图片进行自动压缩处理导致图片模糊发虚。 将碎图合成一张大图，每次进行图片下载时会先进行TCP三次握手协议，这个时间会超过较多小图下载的时间。 使用九宫格时，不要使用非整数宽高；在List控件中不要使用九宫格图片来减少draw的次数。 单静态页面，cacheAsBitMap可以减少重绘次数。如在大图中取出部分碎图组成的单静态页面。 使用SpriteSheet合并的图片尺寸要优于单张图片的总尺寸，尤其是带透明通道的。 NetWork 素材处理。不要一次性下载太多的素材，尽量分布在使用前加载。将碎图和成一张大图，减少下载次数。Png图可以使用压缩工具（如TinyPng）压缩减少体积。 配置文件。尽量将配置文件合并到一个大文件里，减少下载次数。在Http请求中，加载单个文件速度要优于加载多个文件。配置文件去掉格式化，利用在线Json格式化工具（如bejson，sojson）处理Json数据。Json数据可以去掉一些不必要的小数和冗长命名。 下载处理。资源服务器开启GZIP压缩，提高载入速率；登录加主页面素材不要超过2M；加入静默加载，比如在登录界面操作时下载主页面相关素材。 Mask 遮罩如果是DisplayObject，必须加入到显示列表后，方能正常使用。 遮罩如果是Rectangle，修改遮罩数据后，重新将遮罩赋值给对象。 DisplayObject Shape/DisplayObjectContainer，能通过父层计算出来的交互不直接在子容器里加。如EUI中，Group组件中有Image组件，Touch Image的监听直接将Touch监听加在Group上，如果是一个Group中有多张图需要有监听事件，可在Group上加一个监听，根据Group的Touch位置进行响应。 禁用不必要显示对象的触摸交互，默认就是关闭的。但是开发时，自己的写的底层框架可能又给打开了，eui的touchenable是默认打开的，不需要touch事件监听时需手动关闭。触摸屏幕实际上就是触摸canvas,canvas根据位置在显示列表中逐层搜索，实际上也是碰撞检测。 1234567var sp :egret.Sprite = new egret.Sprite();this.addChild(sp);sp.touchChildren = false; //确定子孙对象是否接受触摸事件，默认为truesp.touchEnabled = false; //此对象是否接受触摸事件，默认为true 能用图片的不用Graphics实现。 尽量将静态图或者文字放到一个容器中，并对容器缓存（cacheAsBitMap）。 减少显示对象的旋转及缩放。 尽可能重用对象，建立对象池，而不创建对象并对其执行垃圾回收。创建对象时，将对象创建在循环外部并在循环内反复重用。需要密集的创建对象，要引入对象池，例如做一款打飞机类型的游戏，进入战斗前，飞机，怪物，掉血特效等对象提前初始化，在过程中实时提取，而不是实时创建。 对象复用与释放 Event派发要合理使用Event自带的静态方法，如egret.Event.dispatchEvent(this,”dragonbones”)。 事件删除，用完事件即删除。 Tween循环结束时，删除。 显示列表删除，面板不使用则remove掉。 显示停止计时器，让它们准备好进行垃圾回收。暂停清除计数器clearInterval()、clearTimeout()、Timer.stop()。 TypeScipt 尽量不要在使用方法内创建函数，一个函数内不要嵌套另一个函数的定义 Ts中没有super属性的调用，Js类继承的本质是通过原型链实现的，但是egret提供了egret.superGet 和 egret.superSet 来调用父类属性。 类方法中，将this赋值给另一个临时变量self，var self = this;如果当前类this使用较多，如for循环内使用时，使用self。 其他 LocalToGlobal后的坐标不要有小数；一般情况下坐标计算等也尽量不使用小数。 对象复用比较高时，如打飞机的子弹，使用对象池优化。 尽量减少Alpha混合的使用。 多次调用类属性时，避免直接使用this，如果for循环一直用到this.a，可var _a = this.a，用变量做简单缓存再去计算，效率就会提升，如_length = Array.length。 Event.ENTER_FRAME数量控制。MainLoop包括ENTER_FRAME（每帧主要执行逻辑）-&gt;CLEAR(清空上一帧图像) -&gt;UPDATE TRANSFORM(计算这一帧的显示) -&gt; UPDATE DRAW。 位移如跑酷游戏的计算不要通过帧数来计算，通过时间来计算。 使用60的约数作为帧频数。Egret自带Timer，每秒固定振荡60次。 对于简单的动画，使用序列帧或者db的急速模式。 非动作游戏降低帧率可大幅提高性能。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>TypeScript</tag>
        <tag>Egret</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库范式学习总结]]></title>
    <url>%2F2016%2F08%2F05%2Fdatabase_introduce%2F</url>
    <content type="text"><![CDATA[近期重温数据库范式。 第一范式（1NF）属性不可再分，强调的是原子性。如表：【联系人】（姓名，性别，电话），在实际场景中，联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。要符合 1NF 我们只需把列（电话）拆分，即：【联系人】（姓名，性别，家庭电话，公司电话）。 第二范式（2NF）首先，符合1NF，并且，非主属性完全依赖于码，即没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。强调的是完全依赖而非部分依赖。考虑一个订单明细表：【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName）。 因为我们知道在一个订单中可以订购多种产品，所以单单一个 OrderID 是不足以成为主键的，主键应该是（OrderID，ProductID）。显而易见 Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID。所以 OrderDetail 表不符合 2NF。不符合 2NF 的设计容易产生冗余数据。可以把【OrderDetail】表拆分为【OrderDetail】（OrderID，ProductID，Discount，Quantity）和【Product】（ProductID，UnitPrice，ProductName）来消除原订单表中UnitPrice，ProductName多次重复的情况。 第三范式（3NF）首先，符合 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 强调的是消除传递依赖。考虑一个订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID）。其中 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。通过拆分【Order】为【Order】（OrderID，OrderDate，CustomerID）和【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。 BC范式（BCNF）任何字段都不能传递依赖任一侯选关键字。第三范式为非主键列不能传递依赖，而BC范式为所有键列都不能传递依赖。在第三范式的基础上，进一步消除了主属性的传递依赖。BC范式既检查非主属性，又检查主属性。 第四范式（4CF）把同一表内的多对多关系删除。 第五范式（5CF）从最终结构重新建立原始结构。 正确认识数据冗余主键与外键在多表中的重复出现, 不属于数据冗余，这个概念必须清楚。非键字段的重复出现, 才是数据冗余！而且是一种低级冗余，即重复性的冗余。高级冗余不是字段的重复出现，而是字段的派生出现。例：商品中的“单价、数量、金额”三个字段，“金额”就是由“单价”乘以“数量”派生出来的，它就是冗余，而且是一种高级冗余。冗余的目的是为了提高处理速度。只有低级冗余才会增加数据的不一致性，因为同一数据，可能从不同时间、地点、角色上多次录入。 总结绝大多数实际开发最多用到BC范式。第四和第五范式感兴趣多看看资料，了解即可。范式不是越高越好，过于范式化会对数据库的逻辑可读性和使用效率起到阻碍。数据库连接有性能消耗，实际开发过程中，会有数据冗余，以空间换时间，所以提倡高级冗余(派生性冗余)，反对低级冗余(重复性冗余)。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业]]></title>
    <url>%2F2016%2F06%2F10%2Fgraduate%2F</url>
    <content type="text"><![CDATA[贴几张照片~教学区到体育馆的路上，亮眼的毕业三字-.-来一桶图书馆体育场教学区软院正门对比一下大一青葱： Your browser does not support the audio tag.]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>